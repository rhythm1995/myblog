<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Bugzhang空间</title>
	<link>http://bugzhang.com</link>
	<description>迷失的人迷失了，相逢的人还会相逢</description>
	<pubDate>Thu, 05 Dec 2019 06:36:36 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://bugzhang.com</wp:base_site_url>
	<wp:base_blog_url>http://bugzhang.com</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[bugzhang]]></wp:author_login><wp:author_email><![CDATA[nuptunee@gmail.com]]></wp:author_email><wp:author_display_name><![CDATA[bugzhang]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

		<wp:category>
		<wp:term_id>42</wp:term_id>
		<wp:category_nicename><![CDATA[golang]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[golang]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>40</wp:term_id>
		<wp:category_nicename><![CDATA[http]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[HTTP]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>44</wp:term_id>
		<wp:category_nicename><![CDATA[node-js]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[node.js]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>3</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%89%8d%e7%ab%af]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[前端]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>4</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%90%8e%e7%ab%af]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[后端]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>2</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%89%af%e6%b7%a1%e9%9b%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[扯淡集]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>8</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[操作系统]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>36</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[数据库]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>27</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[数据挖掘]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>1</wp:term_id>
		<wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[未分类]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>5</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[算法]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>9</wp:term_id>
		<wp:category_nicename><![CDATA[%e9%9d%a2%e8%af%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[面试]]></wp:cat_name>
	</wp:category>
			<wp:tag>
		<wp:term_id>20</wp:term_id>
		<wp:tag_slug><![CDATA[css]]></wp:tag_slug>
		<wp:tag_name><![CDATA[CSS]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>14</wp:term_id>
		<wp:tag_slug><![CDATA[css-%e5%89%8d%e7%ab%af-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[CSS 前端 性能优化]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>45</wp:term_id>
		<wp:tag_slug><![CDATA[egg-js]]></wp:tag_slug>
		<wp:tag_name><![CDATA[egg.js]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>43</wp:term_id>
		<wp:tag_slug><![CDATA[golang]]></wp:tag_slug>
		<wp:tag_name><![CDATA[golang]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>41</wp:term_id>
		<wp:tag_slug><![CDATA[http]]></wp:tag_slug>
		<wp:tag_name><![CDATA[HTTP]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>24</wp:term_id>
		<wp:tag_slug><![CDATA[javascript]]></wp:tag_slug>
		<wp:tag_name><![CDATA[JavaScript]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>6</wp:term_id>
		<wp:tag_slug><![CDATA[linux]]></wp:tag_slug>
		<wp:tag_name><![CDATA[linux]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>47</wp:term_id>
		<wp:tag_slug><![CDATA[mysql]]></wp:tag_slug>
		<wp:tag_name><![CDATA[mysql]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>46</wp:term_id>
		<wp:tag_slug><![CDATA[node-js]]></wp:tag_slug>
		<wp:tag_name><![CDATA[node.js]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>49</wp:term_id>
		<wp:tag_slug><![CDATA[webkit]]></wp:tag_slug>
		<wp:tag_name><![CDATA[webkit]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>32</wp:term_id>
		<wp:tag_slug><![CDATA[zepto-js]]></wp:tag_slug>
		<wp:tag_name><![CDATA[zepto.js]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>21</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>11</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af-javascript]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端 javascript]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>12</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端 性能优化]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>29</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端优化]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>23</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端工程化]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>13</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96-%e5%89%8d%e7%ab%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端工程化 前端]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>30</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端底层]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>51</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端架构]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>39</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8a%a0%e5%af%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[加密]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>38</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%8e%e7%ab%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[后端]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>33</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%ae%89%e5%85%a8]]></wp:tag_slug>
		<wp:tag_name><![CDATA[安全]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>22</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[性能优化]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>16</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%89%af%e6%b7%a1]]></wp:tag_slug>
		<wp:tag_name><![CDATA[扯淡]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>34</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8e%a8%e8%8d%90%e7%b3%bb%e7%bb%9f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[推荐系统]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>25</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[操作系统]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>37</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数据库]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>28</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数据挖掘]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>18</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数据结构]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>17</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e7%ae%97%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数据结构 算法]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>52</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%9e%b6%e6%9e%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[架构]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>50</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%b8%b8%e8%a7%88%e5%99%a8]]></wp:tag_slug>
		<wp:tag_name><![CDATA[游览器]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>31</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90]]></wp:tag_slug>
		<wp:tag_name><![CDATA[源码分析]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>19</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ae%97%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[算法]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>35</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%b0%83%e8%af%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[调试]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>7</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%bf%90%e7%bb%b4]]></wp:tag_slug>
		<wp:tag_name><![CDATA[运维]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>15</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%9d%a2%e8%af%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[面试]]></wp:tag_name>
	</wp:tag>
			<wp:term>
		<wp:term_id><![CDATA[20]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[css]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[CSS]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[14]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[css-%e5%89%8d%e7%ab%af-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[CSS 前端 性能优化]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[45]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[egg-js]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[egg.js]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[42]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[golang]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[golang]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[43]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[golang]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[golang]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[40]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[http]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[HTTP]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[41]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[http]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[HTTP]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[24]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[javascript]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[JavaScript]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[6]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[linux]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[47]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[mysql]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[mysql]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[44]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[node-js]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[node.js]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[46]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[node-js]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[node.js]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[49]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[webkit]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[webkit]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[32]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[zepto-js]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[zepto.js]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[26]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[nav_menu]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%b8%bb%e8%8f%9c%e5%8d%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[主菜单]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[3]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[21]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[11]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af-javascript]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端 javascript]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[12]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端 性能优化]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[29]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端优化]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[23]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端工程化]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[13]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96-%e5%89%8d%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端工程化 前端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[30]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端底层]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[51]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端架构]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[39]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a0%e5%af%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[加密]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[48]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[nav_menu]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%8b%e6%83%85%e9%93%be%e6%8e%a5]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[友情链接]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[4]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%8e%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[后端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[38]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%8e%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[后端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[33]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ae%89%e5%85%a8]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[安全]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[22]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[性能优化]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[16]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%89%af%e6%b7%a1]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[扯淡]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[2]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%89%af%e6%b7%a1%e9%9b%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[扯淡集]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[34]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8e%a8%e8%8d%90%e7%b3%bb%e7%bb%9f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[推荐系统]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[8]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[操作系统]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[25]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[操作系统]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[36]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据库]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[37]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据库]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[27]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据挖掘]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[28]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据挖掘]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[18]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据结构]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[17]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据结构 算法]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[1]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uncategorized]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[未分类]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[52]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9e%b6%e6%9e%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[架构]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[50]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%b8%b8%e8%a7%88%e5%99%a8]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[游览器]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[31]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[源码分析]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[5]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[算法]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[19]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[算法]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[35]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%b0%83%e8%af%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[调试]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[7]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%bf%90%e7%bb%b4]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[运维]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[9]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9d%a2%e8%af%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[面试]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[15]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9d%a2%e8%af%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[面试]]></wp:term_name>
	</wp:term>
			<wp:term><wp:term_id>26</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[%e4%b8%bb%e8%8f%9c%e5%8d%95]]></wp:term_slug><wp:term_name><![CDATA[主菜单]]></wp:term_name>
</wp:term>
	<wp:term><wp:term_id>48</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[%e5%8f%8b%e6%83%85%e9%93%be%e6%8e%a5]]></wp:term_slug><wp:term_name><![CDATA[友情链接]]></wp:term_name>
</wp:term>

	

		<item>
		<title>示例页面</title>
		<link>http://bugzhang.com/?page_id=2</link>
		<pubDate>Sat, 23 Dec 2017 09:19:50 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?page_id=2</guid>
		<description></description>
		<content:encoded><![CDATA[这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样：

<blockquote>我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。</blockquote>

……或下面这样：

<blockquote>XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。</blockquote>

作为一个新的WordPress用户，您可以前往<a href="http://bugzhang.com/wp-admin/">您的仪表盘</a>删除这个页面，并建立属于您的全新内容。祝您使用愉快！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2</wp:post_id>
		<wp:post_date><![CDATA[2017-12-23 17:19:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-12-23 09:19:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sample-page]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[15]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>w</title>
		<link>http://bugzhang.com/?attachment_id=15</link>
		<pubDate>Sat, 23 Dec 2017 10:48:07 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/wp-content/uploads/2017/12/w.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>15</wp:post_id>
		<wp:post_date><![CDATA[2017-12-23 18:48:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-12-23 10:48:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[w]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[http://bugzhang.com/wp-content/uploads/2017/12/w.jpg]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2017/12/w.jpg]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1024;s:6:"height";i:640;s:4:"file";s:13:"2017/12/w.jpg";s:5:"sizes";a:8:{s:9:"thumbnail";a:4:{s:4:"file";s:13:"w-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:13:"w-300x188.jpg";s:5:"width";i:300;s:6:"height";i:188;s:9:"mime-type";s:10:"image/jpeg";}s:12:"medium_large";a:4:{s:4:"file";s:13:"w-768x480.jpg";s:5:"width";i:768;s:6:"height";i:480;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:14:"w-1024x640.jpg";s:5:"width";i:1024;s:6:"height";i:640;s:9:"mime-type";s:10:"image/jpeg";}s:15:"yimik-thumb-600";a:4:{s:4:"file";s:13:"w-600x150.jpg";s:5:"width";i:600;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:15:"yimik-thumb-300";a:4:{s:4:"file";s:13:"w-300x100.jpg";s:5:"width";i:300;s:6:"height";i:100;s:9:"mime-type";s:10:"image/jpeg";}s:15:"yimik-thumb-140";a:4:{s:4:"file";s:13:"w-140x100.jpg";s:5:"width";i:140;s:6:"height";i:100;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:13:"w-125x125.jpg";s:5:"width";i:125;s:6:"height";i:125;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>关于我</title>
		<link>http://bugzhang.com/?p=78</link>
		<pubDate>Sat, 23 Dec 2017 15:50:37 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=78</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>78</wp:post_id>
		<wp:post_date><![CDATA[2017-12-23 23:50:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-12-23 15:50:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e6%88%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e4%b8%bb%e8%8f%9c%e5%8d%95"><![CDATA[主菜单]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[78]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[http://bugzhang.com/?p=74]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>友情链接</title>
		<link>http://bugzhang.com/?p=79</link>
		<pubDate>Sat, 23 Dec 2017 15:50:37 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=79</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>79</wp:post_id>
		<wp:post_date><![CDATA[2017-12-23 23:50:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-12-23 15:50:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%a5%bd%e5%8f%8b%e9%93%be%e6%8e%a5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e4%b8%bb%e8%8f%9c%e5%8d%95"><![CDATA[主菜单]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[79]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[http://bugzhang.com/?p=76]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>留言板</title>
		<link>http://bugzhang.com/?p=152</link>
		<pubDate>Mon, 17 Feb 2014 17:02:48 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=152</guid>
		<description></description>
		<content:encoded><![CDATA[大家随意，晚安。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>152</wp:post_id>
		<wp:post_date><![CDATA[2014-02-18 01:02:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-02-17 17:02:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%95%99%e8%a8%80%e6%9d%bf]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[816]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>为什么事业单位和当公务员毫无吸引力</title>
		<link>http://bugzhang.com/?p=157</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=157</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>157</wp:post_id>
		<wp:post_date><![CDATA[2018-02-19 19:53:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title></title>
		<link>http://bugzhang.com/?p=220</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=220</guid>
		<description></description>
		<content:encoded><![CDATA[前段时间参与开发了公司组件库，写了一些东西，也出了一些问题。把开发过程中的一些想法和思路记录一下。

从组件分类开始

组件基本可以分为以下几类，对于每种分类的组件，

├── 基础组件
    ├── aside 侧边框
    ├── layout 布局
    ├── container 布局容器
    ├── dropdown 下拉菜单
    ├── breadcrumb 面包屑
    ├── tabs 标签页
    ├── button 按钮
    ├── card 卡片
    ├── footer 底部
    ├── header 头部
    ├── main 主体
    ├── menu 菜单栏
    ├── navigator 导航
    ├── tabset 标签菜单
├── 通知弹出类组件
    ├── alert 警告
    ├── dialog 对话框
    ├── message 消息提示
    ├── message-box 弹框
    ├── notification 通知
    ├── popover 浮动框
    ├── tooltip 文字提示
├── 表单类组件
    ├── form 表单
    ├── cascader 级联选择器
    ├── checkbox 多选框
    ├── input 输入框
    ├── input-number 数字输入框
    ├── radio 单选框
    ├── select 选择器
    ├── slider 滑块
    ├── switch 开关
    ├── time-picker 时间选择器
    ├── data-picker 日期选择器
    ├── data-time-picker 日期时间选择器
    └── upload 上传
    ├── transfer 穿梭框
    ├── color-picker 颜色选择器
    ├── rate 评分
├── 数据展示类组件
    ├── badge 标记
    ├── carousel 走马灯
    ├── collapse 折叠
    ├── icon 图标
    ├── loading 等待
    ├── tree 树
    ├── pagination 分页
    ├── progress 进度条
    ├── scrollbar 滚轴
    ├── steps 步骤条
    ├── table 表格
    ├── tag 标签
├── 复杂嵌套组件
    ├── chatbox 聊天框
    ├── tree-select 树形级联选择器]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>220</wp:post_id>
		<wp:post_date><![CDATA[2018-11-23 12:04:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>使用javascript描述数据结构——树</title>
		<link>http://bugzhang.com/?p=232</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=232</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>树的定义</h2>

因为树通常可以转为二叉树，所以常见的树算法都是以二叉树为准，二叉树的代码定义：

<pre><code>function TreeNode(value, left, right) {
    this.value = value; // 节点存储的值
    this.left = left; // 左节点
    this.right = right; // 右节点
}
</code></pre>

二叉树有以下特点：
- 二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。
- 二叉树的第 i 层至多有 2^(i-1)个结点。
- 深度为 k 的二叉树至多有 2^k-1个结点。
- 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。
- 一棵深度为k，且有 2^k-1 个节点称之为满二叉树；
- 深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。
- 平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

因为根节点是唯一的，我们通常用根节点的变量指针代替的就是这颗树。同理，任何一个节点的变量也代指了这棵树。

<h2>二叉树的遍历</h2>

二叉树的遍历一共有四种：先序（又叫前序或先根），中序（又叫中序或中根），后序（又叫后序或后根），层序。

所谓“序”指的是根的顺序，即先序是先遍历根，中序是根在中间，后序是根在最后。需要记得的是左右节点的访问顺序都是先左后右的。

二叉树的遍历递归解法都非常简单，非递归解法中和根相关的三种无一例外用到栈，层序会用到队列，这是需要记清楚的。记住这个要点之后，是很容易自己思考出来如何用栈和队列实现空间占用更小的非递归算法。

<h3>先序遍历</h3>

递归的解法：
1.如果树为空，返回
2.否则打印根的值，并且递归调用先序遍历左子树，先序遍历右子树

<pre><code>function preorderTraversalRec(root){
   if (root == null) {
       return;
   }
   console.log(root.value);
   preorderTraversalRec(root.left);
   preorderTraversalRec(root.right);
}
</code></pre>

非递归的解法

<pre><code><br /></code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>232</wp:post_id>
		<wp:post_date><![CDATA[2019-03-01 03:30:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>yimik-0.3.6</title>
		<link>http://bugzhang.com/?p=282</link>
		<pubDate>Mon, 12 Aug 2019 16:34:43 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=282</guid>
		<description></description>
		<content:encoded><![CDATA[/*
您可以在此处加入您的CSS。

点击上方的帮助图标来了解更多。
*/
.yimik-article .entry-content p {font-size: 1.10rem;}

.yimik-article .entry-content li {font-size: 1.10rem;}

#logo a img {vertical-align:top;}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>282</wp:post_id>
		<wp:post_date><![CDATA[2019-08-13 00:34:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 16:34:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[yimik-0-3-6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														</item>
					<item>
		<title>GitHub</title>
		<link>http://bugzhang.com/?p=289</link>
		<pubDate>Mon, 12 Aug 2019 16:59:35 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=289</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>289</wp:post_id>
		<wp:post_date><![CDATA[2019-08-13 00:59:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 16:59:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[github]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e4%b8%bb%e8%8f%9c%e5%8d%95"><![CDATA[主菜单]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[289]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[https://github.com/rhythm1995]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>留言板</title>
		<link>http://bugzhang.com/?p=290</link>
		<pubDate>Mon, 12 Aug 2019 16:59:35 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=290</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>290</wp:post_id>
		<wp:post_date><![CDATA[2019-08-13 00:59:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 16:59:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%95%99%e8%a8%80%e6%9d%bf]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e4%b8%bb%e8%8f%9c%e5%8d%95"><![CDATA[主菜单]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[290]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[http://bugzhang.com/?p=152]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>justzht（天哥，ios&amp;unity）</title>
		<link>http://bugzhang.com/?p=293</link>
		<pubDate>Mon, 12 Aug 2019 17:03:00 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=293</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>293</wp:post_id>
		<wp:post_date><![CDATA[2019-08-13 01:03:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 17:03:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[justzht%ef%bc%88%e5%a4%a9%e5%93%a5%ef%bc%8cios%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e5%8f%8b%e6%83%85%e9%93%be%e6%8e%a5"><![CDATA[友情链接]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[293]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[https://www.justzht.com/]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>x-fei（飞飞，中山大学CV）</title>
		<link>http://bugzhang.com/?p=294</link>
		<pubDate>Mon, 12 Aug 2019 17:03:00 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=294</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>294</wp:post_id>
		<wp:post_date><![CDATA[2019-08-13 01:03:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-12 17:03:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[x-fei%ef%bc%88%e9%a3%9e%e9%a3%9e%ef%bc%8c%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e5%8f%8b%e6%83%85%e9%93%be%e6%8e%a5"><![CDATA[友情链接]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[294]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[https://blog.x-fei.me]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>从零开始前端架构1：现代前端工作流</title>
		<link>http://bugzhang.com/?p=325</link>
		<pubDate>Sun, 15 Sep 2019 15:28:35 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=325</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>软件架构</h1>

<h2>什么是软件架构</h2>

对于计算机工程而言，“架构”是一个十足的“舶来品”，最出“架构”是从建筑工程系来的一个概念，对于建筑工程而言，需要规划、设计、实施等多个过程，中间需要考虑成本、功能、美观、坚固等诸多需求，因此一个合适的建筑蓝图和计划，对于建筑工程而言至关重要。

软件开发也是和建筑工程类似，我们需要一个类似于建筑工程中的架构，来指导我们的开发工作，包括：

<ul>
<li>各个模块之间关系是什么？</li>
<li>采用什么技术栈、框架等来完成各个模块？</li>
<li>各个模块如何通信？</li>
<li>项目如何上线和部署？</li>
<li>各个模块中的结构细节如何？</li>
<li>开发测试部署中的约定、规则和制度？</li>
<li>对于程序员来说如何遵循上述这些细节？</li>
</ul>

<h2>需要怎样的架构</h2>

<ul>
<li>一个能够上线部署的架构</li>
<li>一个团队所有人都能完成部分工作，集体可以完成全部工作的架构</li>
<li>一个技术上可行的架构</li>
<li>一个不多也不少刚刚好的架构</li>
<li>一个可持续可维护可拓展的架构</li>
</ul>

<h2>架构的设计步骤</h2>

<ol>
<li>收集业务需求</li>
<li>与具体开发人员沟通了解技术限制（比如用了大家不会的技术做了主方案就是极不可取的选择，遵循团队传统是一个优秀架构设计人员必须具有的素质）</li>
<li>寻找潜在的可行性技术方案</li>
<li>发现可能的风险点</li>
<li>在团队中确认并证明方案可行性</li>
<li>细化技术方案的每个阶段实施</li>
<li>结合业务和工作量，按照轻重缓急法，对项目进行排期</li>
</ol>

<h1>前端技术发展史</h1>

<ul>
<li>石器时代（1990-1995）：彼时js还没有诞生，由后端渲染HTML，前端只包括布局和简单的样式。</li>
<li>青铜时代（1995-2005）：js开始诞生，前端可以用js实现一些动效以及表单校验等工作。后来者的IE游览器与网景进行第一次游览器大战并胜利。</li>
<li>铁器时代（2005-2008）：2005年，gmail采用ajax进行开发，是第一个动态页面，之后ajax开始流行。同时flash和ActionScript大行其道。</li>
<li>蒸汽时代(2008-2009)：2008年，现代游览器内核webkit和强力js引擎V8发布并开源，2年后苹果开始抵制flash强推html5。</li>
<li>电气时代（2009-2013）:node.js和npm发布，angular.js发布。</li>
<li>现代（2013后）：react.js和vue.js及其生态圈内模块相继发布，带来新的思维组件化和数据驱动；出现了typescript；ES6发布并且持续跟进；gulp和webpack作为自动化和打包工具的代表发布；跨平台框架Electron、RN、Flutter等被发布并且强力承担了当前移动端开发半数以上工作；node.js趋于稳定并且承担了大量项目的后台开发；游览器随着性能的提高使得游览器三维越来越流行。</li>
</ul>

<h1>前端架构的层次</h1>

<img src="http://img.bugzhang.com/architecture-level.jpg" alt="" />

<ul>
<li>系统级：应用在整个系统内的架构关系，即与后端如何组织结构</li>
<li>应用级：应用外部的架构关系，如多个应用之间的组件共享</li>
<li>模块级：应用内部的架构关系，如状态管理、模块化</li>
<li>代码级：代码级别的基础设施，包括规范、原则、文档等</li>
</ul>

<h1>工作流和构建流</h1>

<h2>工作流</h2>

<img src="http://img.bugzhang.com/workflow.jpg" alt="前端工作流" />

<h2>构件流</h2>

<img src="http://img.bugzhang.com/build-workflow.jpg" alt="前端构建流" />

<h2>开发中一些常见的文档对比</h2>

<table>
<thead>
<tr>
  <th>类型</th>
  <th align="center">适用场景</th>
  <th align="center">使用频率</th>
  <th align="center">性价比</th>
</tr>
</thead>
<tbody>
<tr>
  <td>搭建指南README</td>
  <td align="center">项目搭建和开发</td>
  <td align="center">低</td>
  <td align="center">高</td>
</tr>
<tr>
  <td>架构图</td>
  <td align="center">熟悉项目设计</td>
  <td align="center">低</td>
  <td align="center">高</td>
</tr>
<tr>
  <td>看板</td>
  <td align="center">了解业务，把控进度</td>
  <td align="center">中</td>
  <td align="center">中</td>
</tr>
<tr>
  <td>需求追踪</td>
  <td align="center">了解需求，追踪进度</td>
  <td align="center">高</td>
  <td align="center">高</td>
</tr>
<tr>
  <td>bug追踪</td>
  <td align="center">追踪bug情况</td>
  <td align="center">高</td>
  <td align="center">高</td>
</tr>
<tr>
  <td>代码规范与提交规范</td>
  <td align="center">如何提交和规范代码</td>
  <td align="center">高</td>
  <td align="center">高</td>
</tr>
<tr>
  <td>接口文档</td>
  <td align="center">了解接口</td>
  <td align="center">高</td>
  <td align="center">高</td>
</tr>
</tbody>
</table>

这里顺便讲下代码commit规范，我通常采用的是一个简洁的规范，这个规范是：

【类型】(【影响范围-可选】):【修改内容】

其中类型有以下几种：

<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>style：写了css样式（不影响代码运行的变动）</li>
<li>docs：补充文档（documentation）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>build：构建过程或辅助工具的变动</li>
</ul>

--

参考：

<ul>
<li>《前端架构-从入门到微前端》</li>
<li>《整洁架构》</li>
<li>《软件系统架构》</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>325</wp:post_id>
		<wp:post_date><![CDATA[2019-09-15 23:28:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-15 15:28:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%841%ef%bc%9a%e7%8e%b0%e4%bb%a3%e5%89%8d%e7%ab%af%e5%b7%a5%e4%bd%9c%e6%b5%81]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84"><![CDATA[前端架构]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%841%ef%bc%9a%e7%8e%b0%e4%bb%a3%e5%89%8d%e7%ab%af%e5%b7%a5%e4%bd%9c%e6%b5%81__trashed]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>nastul（霖哥，墨尔本大学人工智能）</title>
		<link>http://bugzhang.com/?p=341</link>
		<pubDate>Mon, 21 Oct 2019 12:44:13 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=341</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>341</wp:post_id>
		<wp:post_date><![CDATA[2019-10-21 20:44:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-21 12:44:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[nastul%ef%bc%88%e9%9c%96%e5%93%a5%ef%bc%8c%e5%a2%a8%e5%b0%94%e6%9c%ac%e5%a4%a7%e5%ad%a6%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="nav_menu" nicename="%e5%8f%8b%e6%83%85%e9%93%be%e6%8e%a5"><![CDATA[友情链接]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[341]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
		<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
		<wp:meta_value><![CDATA[http://blog.nastul.com/]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>image</title>
		<link>http://bugzhang.com/?attachment_id=348</link>
		<pubDate>Fri, 01 Nov 2019 05:58:59 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/wp-content/uploads/2019/11/image.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>348</wp:post_id>
		<wp:post_date><![CDATA[2019-11-01 13:58:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-01 05:58:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[image]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>347</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[http://bugzhang.com/wp-content/uploads/2019/11/image.png]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2019/11/image.png]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:542;s:6:"height";i:316;s:4:"file";s:17:"2019/11/image.png";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:17:"image-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:17:"image-300x175.png";s:5:"width";i:300;s:6:"height";i:175;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-600";a:4:{s:4:"file";s:17:"image-542x150.png";s:5:"width";i:542;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-300";a:4:{s:4:"file";s:17:"image-300x100.png";s:5:"width";i:300;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-140";a:4:{s:4:"file";s:17:"image-140x100.png";s:5:"width";i:140;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:17:"image-125x125.png";s:5:"width";i:125;s:6:"height";i:125;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>image-1</title>
		<link>http://bugzhang.com/?attachment_id=349</link>
		<pubDate>Fri, 01 Nov 2019 06:01:48 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/wp-content/uploads/2019/11/image-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>349</wp:post_id>
		<wp:post_date><![CDATA[2019-11-01 14:01:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-01 06:01:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[image-1]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>347</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[http://bugzhang.com/wp-content/uploads/2019/11/image-1.png]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2019/11/image-1.png]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:542;s:6:"height";i:316;s:4:"file";s:19:"2019/11/image-1.png";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:19:"image-1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:19:"image-1-300x175.png";s:5:"width";i:300;s:6:"height";i:175;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-600";a:4:{s:4:"file";s:19:"image-1-542x150.png";s:5:"width";i:542;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-300";a:4:{s:4:"file";s:19:"image-1-300x100.png";s:5:"width";i:300;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-140";a:4:{s:4:"file";s:19:"image-1-140x100.png";s:5:"width";i:140;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:19:"image-1-125x125.png";s:5:"width";i:125;s:6:"height";i:125;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>image-2</title>
		<link>http://bugzhang.com/?attachment_id=350</link>
		<pubDate>Fri, 01 Nov 2019 06:02:28 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/wp-content/uploads/2019/11/image-2.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>350</wp:post_id>
		<wp:post_date><![CDATA[2019-11-01 14:02:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-01 06:02:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[image-2]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>347</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[http://bugzhang.com/wp-content/uploads/2019/11/image-2.png]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2019/11/image-2.png]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:542;s:6:"height";i:436;s:4:"file";s:19:"2019/11/image-2.png";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:19:"image-2-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:19:"image-2-300x241.png";s:5:"width";i:300;s:6:"height";i:241;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-600";a:4:{s:4:"file";s:19:"image-2-542x150.png";s:5:"width";i:542;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-300";a:4:{s:4:"file";s:19:"image-2-300x100.png";s:5:"width";i:300;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-140";a:4:{s:4:"file";s:19:"image-2-140x100.png";s:5:"width";i:140;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:19:"image-2-125x125.png";s:5:"width";i:125;s:6:"height";i:125;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>image-3</title>
		<link>http://bugzhang.com/?attachment_id=351</link>
		<pubDate>Fri, 01 Nov 2019 06:02:53 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/wp-content/uploads/2019/11/image-3.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>351</wp:post_id>
		<wp:post_date><![CDATA[2019-11-01 14:02:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-01 06:02:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[image-3]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>347</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[http://bugzhang.com/wp-content/uploads/2019/11/image-3.png]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2019/11/image-3.png]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:883;s:6:"height";i:443;s:4:"file";s:19:"2019/11/image-3.png";s:5:"sizes";a:7:{s:9:"thumbnail";a:4:{s:4:"file";s:19:"image-3-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:19:"image-3-300x151.png";s:5:"width";i:300;s:6:"height";i:151;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:19:"image-3-768x385.png";s:5:"width";i:768;s:6:"height";i:385;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-600";a:4:{s:4:"file";s:19:"image-3-600x150.png";s:5:"width";i:600;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-300";a:4:{s:4:"file";s:19:"image-3-300x100.png";s:5:"width";i:300;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-140";a:4:{s:4:"file";s:19:"image-3-140x100.png";s:5:"width";i:140;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:19:"image-3-125x125.png";s:5:"width";i:125;s:6:"height";i:125;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>image-4</title>
		<link>http://bugzhang.com/?attachment_id=352</link>
		<pubDate>Fri, 01 Nov 2019 06:03:36 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/wp-content/uploads/2019/11/image-4.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>352</wp:post_id>
		<wp:post_date><![CDATA[2019-11-01 14:03:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-01 06:03:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[image-4]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>347</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
						<wp:attachment_url><![CDATA[http://bugzhang.com/wp-content/uploads/2019/11/image-4.png]]></wp:attachment_url>
											<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
		<wp:meta_value><![CDATA[2019/11/image-4.png]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:5:{s:5:"width";i:890;s:6:"height";i:565;s:4:"file";s:19:"2019/11/image-4.png";s:5:"sizes";a:7:{s:9:"thumbnail";a:4:{s:4:"file";s:19:"image-4-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:19:"image-4-300x190.png";s:5:"width";i:300;s:6:"height";i:190;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:19:"image-4-768x488.png";s:5:"width";i:768;s:6:"height";i:488;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-600";a:4:{s:4:"file";s:19:"image-4-600x150.png";s:5:"width";i:600;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-300";a:4:{s:4:"file";s:19:"image-4-300x100.png";s:5:"width";i:300;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:15:"yimik-thumb-140";a:4:{s:4:"file";s:19:"image-4-140x100.png";s:5:"width";i:140;s:6:"height";i:100;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:19:"image-4-125x125.png";s:5:"width";i:125;s:6:"height";i:125;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>学什么编程语言</title>
		<link>http://bugzhang.com/?p=1</link>
		<pubDate>Fri, 23 Dec 2016 09:19:50 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[该学什么编程语言。<a href="http://7xqgks.com1.z0.glb.clouddn.com/bugzhangwhat-language-should-i-study.png">点击查看大图</a>
                    <img src="http://7xqgks.com1.z0.glb.clouddn.com/what-language-should-i-study.jpg" alt="" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date><![CDATA[2016-12-23 17:19:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-12-23 09:19:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hello-world]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%89%af%e6%b7%a1"><![CDATA[扯淡]]></category>
		<category domain="category" nicename="%e6%89%af%e6%b7%a1%e9%9b%86"><![CDATA[扯淡集]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[818]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>将项目从 GitHub 部署到服务器</title>
		<link>http://bugzhang.com/?p=21</link>
		<pubDate>Sat, 23 Jan 2016 15:22:35 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=21</guid>
		<description></description>
		<content:encoded><![CDATA[原文转载自<a href="http://www.oschina.net/translate/deploying-from-github-to-a-server">开源中国翻译</a>，一大半是我翻译的。

<hr />

GitHub以及它所依赖的版本控制系统Git，绝对是非常出色的项目管理和协作的工具，不管项目是不是跟代码相关。
本文会讨论有哪些选项可以让Git和Github更好的融入项目的工作流当中，以实现平滑的自动化的过程。
我把这些选项划分到不同的工具集当中，这些集合包括自动运行测试，以及拉取代码部署到服务器上等等。

<h2>为何要这样做？</h2>

有了这些自动化过程的运行，你和你的团队就可以只关注单纯的编码以及代码的合并，而不是每次build的时候都要花费几个小时去重复的做部署这样的事情。

自动化部署变化的主要问题是变化会自动地被部署。你必须信任你的团队以及他们写的代码。这就是为什么自动化部署和自动化测试的搭配成为典型，而下面提供的工具也反映了这一点。

<h2>Git Hooks（钩子）</h2>

Git内置了一套拓展框架叫做钩子（http://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks）用来处理自动化部署，并且这些钩子一般在被特定的Git事件 ( certain points)触发后被调用在我们的第一端口用来处理任务。钩子可以被分为服务器端钩子与客户端钩子。

服务器端是用于监听网络操作的事件 ——比如，当存储库接收推送后。而客户端挂钩的触发是因为开发者进行了操作，如提交和合并。

这是在Git文档中hooks的完整列表(http://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)。 我会注释一对情侣在这里让你开始。希望这能让你在自己当前手动部署的项目工作流程中中变得非常有用。Hooks可以在任何语言的项目部署中运行，强大而灵活。

<h2>pre-commit</h2>

此这个钩子运行在其他所有钩子之前，并且在更改提交之前。可以用来在提交前检查代码错误。

我们在这里写一个JavaScript的小项目说明（当然，我故意留了你可以找到的bug）。

重命名hooks/pre-commit.sample 为 hooks/pre-commit，并进行如下测试命令，以这样的内容：

<pre><code>&amp;lt;br&amp;gt;
`#!/bin/shjshint index.js`&amp;lt;br&amp;gt;
试着提交这个变动：
`git commit -m &amp;quot;adding Javascript 
你可以看到报错信息：&amp;lt;br&amp;gt;
`index.js: line 5, col 25, Missing semicolon.1 error`
</code></pre>

添加缺少的分号后重新提交，不在报错。

<h2>post-receive</h2>

当推送远程Git仓库完成时，服务器端的该钩子触发。在这个例子中，我们推出一个简单的网站的最新版本到你的Web服务器目录，实际上是一个（最基本的）部署。

我有一个现有的网站包含有一个index.html页 - 以及我们在后面的例子将使用的其他网页。你也可以创建自己的，使用在这里设立仓库。

克隆仓库，通过指定--bear标记来创建一个只包含版本控制信息的存储库，而不是我们的代码仓库：<br>

<pre><code>git clone --bare https://github.com/sitepoint-editors/GitHub-Auto-Deploy.git GitHu`&amp;lt;br&amp;gt;
现在我们添加钩子：
`cd GitHub-Auto-Deploy.git/hooksvi post-receive`
添加这些到文件中：&amp;lt;
`git clone --bare https://github.com/sitepoint-editors/GitHub-Auto-Deploy.git GitHub-Auto-Deploy.git`&amp;lt;
现在我们添加钩子：
`cd GitHub-Auto-Deploy.git/hooksvi post-receive`&amp;lt;
添加这些到文件中：
`#!/bin/shgit --work-tree=/var/www/html --git-dir=/var/repo/GitHub-Auto-Deploy.git checkout -f`&amp;lt;
</code></pre>

注意：这些路径是基于Ubuntu环境下完成，所以记得要改变路径，以满足你的路径。
该命令将推出当前仓库到定义的工作目录，但没有任何版本控制数据。
更改文件属性使之可执行：
<code>chmod +x post-receive</code>&lt;br&gt;

小贴士：这些位置与Ubuntu的安装路径相关，所以一定记得要改变路径，以满足您的设置。该命令将检查当前的存储库到定义的工作目录，但没有任何版本控制数据。

将文件添加可执行的权限：&lt;br&gt;

<code>chmod +x post-receive</code>&lt;br&gt;
在你的本地端，像平时一样克隆这个库，使用你选择的工具，并添加一个新的远程的实时服务器（记得更改服务器的详细信息到你的Web服务器和用户的详细信息）：&lt;br&gt;

<code>git remote add prod ssh://user@domain.com/var/repo/GitHub-Auto-Deploy.git</code>&lt;br&gt;

要部署到我们生产环境下的服务器来替代仓库，输入以下命令：

<code>git push prod master</code>&lt;br&gt;

你可以ls一下服务器的  var/www/html  目录，可以看到index.html文件已经被自动拷贝进你的web文件夹内啦。

如果你使用的是自己的Git仓库，你可以把它配置在同一台服务器上的应用，并实现自动化部署。如果你使用的是GitHub上或其他外部Git的服务，那么这个钩子还没有完全自动化，但它已经降到了一步。这可以进一步简化。

GitHub的post-receive 钩子中有一个可以使用reync或scp的选项。这是另外的一种选择——特别是当你的应用需要构建时（GitHub限制了可能的命令）——是使用post-receive 钩子来触发，然后使用-f选项可以检查出从GitHub的代码库的应用程序服务器上的脚本和运行其他一些必要的命令。这个时候，自动化部署开始变得复杂起来，我们不得不使用下一套工具来更好的完成。

<h2>从 GitHub 直接自动部署</h2>

GitHub 有它自己的文档来自动化部署到集成平台，这里包括一些托管提供商。

老实说，大部分文档都有些错误，不准确或者没有起到作用， 在一些主流的主机提供商那儿，我做了一些搜索链接到官方文档，对于其他一些提供商，我建议你使用 post-receiveor 持续集成的方法：&lt;br&gt;
Heroku
AWS
Azure

<h2>持续集成(CI)服务</h2>

有许多无数的能够查看 GitHub 项目回购变更协议的应用服务，不仅能够为你部署，而且能够执行其他功能，诸如为你运行测试和构建过程。

一旦你移动到一个新的和更复杂的实例时，我们可以使用 CI

自动化构建项目过程。首先，拉伸一个存储库的 Master 分支，然后触发一个运行构建的 bash 脚本，并且部署流程以及对微博更新。CI 与 web 服务能够在同一台服务器上或者在不同的服务器上运行，这一切都取决于你的偏好。

<h2>Jenkins</h2>

你需要搭建你自己的 Jenkins 服务器，这意味着你可以完全地控制它，但必须要对它进行维护。幸运的是，它提供了多平台支持，如果你只是想要先简单尝试一下的话，这些支持也包括了 Docker。

Jenkins 使用插件实现了自己的大部分功能，并且由于其年代久远、开源的性质以及普及度很广，它拥有很多的插件。例如，有一些 Git、GitHub 和 Twitter 的相关插件。

Jenkins 需要大量的配置，而且有时，若想要将你需要的指令组合到一起来构造你所需的工作流程，可能需要大量的研究。

<h2>Travis</h2>

此外，在 GitHub 文档中，使用 GitHub 的 Travis 集成指令已经过时。现在，它更简单：阅读找出更多的 Travis 文档。

Travis 不需要任何主机与服务器设置，因此你无需投入太多的精力，就可以保持和试用CI，这是一个很好的起点。不过，扩展超出（综合）默认的集成将涉及到一些额外的配置工作。比如，微博请求对 webhooks 的访问。

在回购中，你会注意到 Travis-- 特别是在配置自己的文件中，它有一个习惯，就是更新太慢。当你本身没有对 Travis 服务器进行访问时，那么这些问题就难以解决。

<h2>其他商业服务</h2>

持续集成已经日益流行了，所以已经有了非常多的新的服务和应用程序 – 很多是通过你可能已经在使用的工具的创作者释出的，并且将很和谐的融入到现有的工具链和工作流程当中。这里有些例子：
https://buddy.works/
https://www.atlassian.com/software/bamboo/
https://www.jetbrains.com/teamcity/
https://codeship.com/
https://circleci.com/
https://saucelabs.com/
https://about.gitlab.com/gitlab-ci/
http://deploybot.com/

<hr />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>21</wp:post_id>
		<wp:post_date><![CDATA[2016-01-23 23:22:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-23 15:22:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%b0%86%e9%a1%b9%e7%9b%ae%e4%bb%8e-github-%e9%83%a8%e7%bd%b2%e5%88%b0%e6%9c%8d%e5%8a%a1%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="linux"><![CDATA[linux]]></category>
		<category domain="category" nicename="%e6%89%af%e6%b7%a1%e9%9b%86"><![CDATA[扯淡集]]></category>
		<category domain="post_tag" nicename="%e8%bf%90%e7%bb%b4"><![CDATA[运维]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[476]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_fc616080da5cbb2097290f7327c2cbb9]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_a64d6bb97950ecee7deb6681539e214f]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_d47eda8bc92f3e181ab2c8ad599b0be7]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_af3dd8d20d497a7a2a42efeffe6de060]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_8d01d58d82e0a3b5dbd33ef8894a0b64]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_399d410e60c4ab0d02853c977898733d]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_6c750cc846397edd11f534969d3d9b20]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_6270b5cd418629154091dab500b15d05]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>操作系统——处理器调度笔记</title>
		<link>http://bugzhang.com/?p=23</link>
		<pubDate>Wed, 13 Jan 2016 11:33:44 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=23</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="//7xqgks.com1.z0.glb.clouddn.com/870ec29801bdebb797b218c205659bb391b19ce8e5db-euBILP.jpeg" alt="" />

<h3>一、基本概念</h3>

1 作业：比程序更为广泛，不仅包含了通常的程序和数据，还包含了一份作业说明书，系统通过说明书对程序进行控制。

2 作业步：在作业运行期间，每个作业需要的顺序运行步骤。编译、连续装配、运行。

3 作业流：多个在内存存放的作业是输入作业刘；在操作系统控制，逐个进行处理的作业是处理作业流。

4 队列中的记录通常是进程的进程控制块

5 CPU的调度决策可在如下四种环境下发生 {a 当一个进程从运行状态切换到等待状态 b 当一个进程从运行状态切换到就绪状态 c 当一个进程从等待状态切换到就绪状态 d 当一个进程终止}

当调度只能发生在第一和第四种情况时，称调度方案是非抢占的，否则调度方案是可抢占的

采用非抢占调度，一旦CPU被分配给一个进程，那么该进程会一直使用CPU直到进程终止或切换到等待状态时释放CPU

<h3>二 调度准侧</h3>

1 CPU使用率：40 % 到90 % 2 吞吐量：一个单元时间内所完成进程的数量

3 周转时间：从进程提交到进程完成的时间间隔称为周转时间，周转时间是所有时间段之和，包括等待进入内存、在就绪队列中等待，在CPU上执行和I / O执行

4 等待时间：CPU调度算法并影响进程运行和执行I / O的时间量。只影响进程在就绪队列中等待所花费的时间

5 响应时间：从提交请求到产生第一响应的时间。是开始相应所需要的时间，而不是输出该响应所需要的时间

6 调度准则：对于系统，CPU使用率和吞吐量最大化，各类资源平衡利用；对于用户，周转时间、等待时间和相应时间最小，遵循优先权准则

<h3>三 CPU调度算法</h3>

1 先到先服务调度算法 FCFS

2 短作业有限调度算法

3 高优先权优先调度算法

每个进程都有一个优先权与其关联，具有最高优先权的进程会被最先分配到CPU资源，具有相同优先权的采用FCFS调度

优先权可以通过内部或外部方式来定义

优先权调度可以是抢占的或者非抢占的

优先权调度算法的一个主要问题是无穷阻塞。解决办法是老化，老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先权。

4 轮转法调度算法

专门为分时系统设计的，定义一个小时间单元，称为时间量或时间片。时间片通常为10ms到100ms。就绪队列作为循环队列处理。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片间隔的CPU。

如果上下文切换时间约为时间片的10 % ，那么约10 % 的CPU时间会浪费在上下文转换上。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>23</wp:post_id>
		<wp:post_date><![CDATA[2016-01-13 19:33:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-13 11:33:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f-%e5%a4%84%e7%90%86%e5%99%a8%e8%b0%83%e5%ba%a6%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f"><![CDATA[操作系统]]></category>
		<category domain="post_tag" nicename="%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f"><![CDATA[操作系统]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[545]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>哈夫曼树与哈夫曼编码器（python实现）</title>
		<link>http://bugzhang.com/?p=26</link>
		<pubDate>Tue, 23 Aug 2016 11:38:40 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=26</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/bd831b25b5ba1b236a4fa05e0abe01b1f3c0c68124577-hJCX6a.jpg" alt="" />

<h3>1.关于哈夫曼树</h3>

哈夫曼树基于加权二叉树，其基本要素包含左右子树、双亲、权重和编码。

<pre><code>class Node:
    def  __init__(self,right=None,left=None,parent=None,weight=0,charcode=None):
    self.right = right
    self.left = left
    self.parent = parent
    self.weight = weight
    self.charcode = charcode
</code></pre>

<h3>2.哈弗曼算法</h3>

哈弗曼算法属于贪心法的一种，其基本思路是：编码以字符出现的频率作为权重，每次选权重最小的两个节点作为生成最优二叉树的左右孩子，并将权重之和作为根节点的权重，自底向上生成一颗带权路径长度最短的最优二叉树。

<pre><code>def sort(list):
    return sorted(list,key=lambda node:node.weight)

def Huffman(listOfNode):
    listOfNode = sort(listOfNode)
    while len(listOfNode) != 1:
        a,b = listOfNode[0],listOfNode[1]
        new = Node()
        new.weight, new.left, new.right = a.weight + b.weight, a, b
        a.parent, b.parent = new, new
        listOfNode.remove(a), listOfNode.remove(b)
        listOfNode.append(new)
        listOfNode = sort(listOfNode)
    return listOfNode
</code></pre>

<h3>3.导入字符-权重文件（非算法思想部分）</h3>

为方便操作，将字符-权重字典保存为文本文件后，直接导入进行编码，使用Python文件曹组完成。

<pre><code>def inPutFile():
    global filename
    global listForEveryByte
    filename = raw_input("请输入要编码的文件(存放在源代码目录下)：")
    global codeDict
    with open(filename,'rb') as f:
        data = f.read()
        for Byte in data:
            codeDict.setdefault(Byte,0) #每个字节出现的次数默认为0
            codeDict[Byte] += 1
            listForEveryByte.append(Byte)

def outputCompressedFile():
    global listForEveryByte
    fileString = ""
    with open(filename.split(".")[0]+".jbj","wb") as f:
        for Byte in listForEveryByte:
            fileString += encodeDict[Byte]  #构成一个长字符序列
        leng = len(fileString)
        more = 16-leng%16
        fileString = fileString+"0"*more          #空位用0补齐

        leng = len(fileString)
        i,j = 0,16
        while j &lt;= leng:
            k = fileString[i:j]
            a = int(k,2)
            print(a)
            print(repr(struct.pack("&gt;H",a)))
            f.write(struct.pack("&gt;H",a))
            f.write(str(a))
            i=i+16
            j=j+16
</code></pre>

<h3>4.编码</h3>

通过哈弗曼算法构造哈夫曼树后，编码过程为找到字符所在的叶子节点，以及从根节点到该叶子节点的路径，使用先序遍历的节点左树记为0，右树记为1，即可得到编码结果。

<pre><code>def encode(head,listOfNode):
    global encodeDict
    for e in listOfNode:
        ep = e
        encodeDict.setdefault(e.charcode,"")
        while ep != head:

            if ep.parent.left == ep:
                encodeDict[e.charcode] = "1"+encodeDict[e.charcode]
            else:
                encodeDict[e.charcode] = "0"+encodeDict[e.charcode]
            ep=ep.parent
</code></pre>

<h3>5.执行算法与所得结果</h3>

<pre><code>if __name__ == '__main__':
    inPutFile()
    listOfNode = []
    for e in codeDict.keys():
        listOfNode.append(Node(weight=codeDict[e],charcode=e))
    head=Huffman(listOfNode)[0]
    encode(head,listOfNode)

    for i in encodeDict.keys():
        print(i,encodeDict[i])
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>26</wp:post_id>
		<wp:post_date><![CDATA[2016-08-23 19:38:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-08-23 11:38:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91%e4%b8%8e%e5%93%88%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81%e5%99%a8%ef%bc%88python%e5%ae%9e%e7%8e%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[935]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>大二小结</title>
		<link>http://bugzhang.com/?p=28</link>
		<pubDate>Sun, 10 Jul 2016 11:41:39 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=28</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0010.jpg" alt="" />

做完今天的电子设计，就是大二的结束了，感觉到时间的飞快，只剩下一年准备工作了。作为学渣一个我应该是不读研也考不上研的，不过潜意识一直认为，靠谱点的公司工作了三年的工程师技术绝对是吊打学校里读三年的研究生的，自然内心也对继续读书没有什么趋同感。虽然家里从上到下都要求让我读研，虽然无论他们还是我自己都不知道那种选择更好，不过近两年努力（挂了三科却学得了一点点技术，如果今年不重修完估计得延迟毕业了得）老爸不像之前那样觉得读研是必须的了，说能本科毕业就好。但即使如此也倍感压力之大，毕竟之前浪费了不少时间，现在得付出十二分的时间补一下技术，，按照目前进度觉得一年还是足够的还能留出来至少两个月上牛客准备刷下笔试题和面试题，看看剑指offer之类的，但愿学校大三不在有各种奇奇怪怪的事情就行（诸如这个假期近十天的课设+课设前假期让我不得不鸽掉本来准备的实习）。估计是既不擅长电子相关课程的原因，我内心对所有和电子直接相关的课程和老师都很排斥，以至于大学挂的三门课全部都是电子（数电、模电、通信原理）的，换句话说是极为讨厌硬件相关的。

<h3>我的大二时间线</h3>

2015 年9月：继续上一个项目，一个关于物流的网站开发。

2015 年10月：中南大学有色金属出版社网站开发。

2015 年11月：颓废的一个月，现在也想不起干了什么，学了什么。

2015 年12月：开始了解angular和node.js，准备走大前端，但学习遇上很多问题并且较难解决，中途暂时放弃。

2016 年1月：考试接近，复（yu）习（xi），第一次开始一天一本书，一夜一门课的玩命模式。

2016 年2月：回家，春节，购买了DO的国外服务器以免去备案的麻烦，搭建了博客准备记录以后，继续学了一段时间前端，重构了去
年的物流网站项目。

2016 年3月：返校，帮学长开发学校招聘网.

2016 年4月：补了《白色相簿2》，短短13集的动漫，却中毒颇深，后来玩了这款gal，此生无悔入白学。

2016 年5月：作为外包开发学校学生团队做的二手平台，据说后来他们拿了金奖并且基本拿下国赛，邀请我加入时候回绝了虽然知道拿下国赛意味着保研至少也是加分，但学校的那类比赛已经和我价值观冲突了许多。

2016 年6月：学了一段时间代码，月底考试，开始预习，一天一本书效果不错，基本全部过了。

2016 年7月：终于放假，准备过充电和学习为主的假期，间隔计划见高中同学。

总之这一年丧失诸多之前的热情，能力也变得平庸而没有大一的锐气，或者说我可能本来就是那种有想法没天赋和坚持的，很多本来能做好的被白白浪费，也没有勇气追求，或者说之前会的很多都是因为别人没有去学才能超越的，如果这样那下一年可能就会被更多人在技术上超越，所以必须重新继续了。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>28</wp:post_id>
		<wp:post_date><![CDATA[2016-07-10 19:41:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-07-10 11:41:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%a4%a7%e4%ba%8c%e5%b0%8f%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%89%af%e6%b7%a1"><![CDATA[扯淡]]></category>
		<category domain="category" nicename="%e6%89%af%e6%b7%a1%e9%9b%86"><![CDATA[扯淡集]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[490]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>正则表达式总结</title>
		<link>http://bugzhang.com/?p=30</link>
		<pubDate>Wed, 16 Aug 2017 14:48:31 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=30</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0011.jpg" alt="" />

<h5>常规</h5>

<ul>
<li>.：任意字符，行结束符除外，要匹配行结束符，使用[\s\S]</li>
<li>\d：任意数字，\D任意非数字</li>
<li>\w：字母数字类字符，\W任意非字母数字</li>
<li>\s：空白字符（空格、制表符、换行符、回车符、翻页符），\S任意不是空白符的字符</li>
<li>\b：匹配单词的开始或结束，\B 匹配不是单词开头或结束的位置</li>
<li>^：匹配字符串的开始</li>
<li>$：匹配字符串的结束</li>
</ul>

<h5>量词</h5>

<ul>
<li>*：重复零次或更多次</li>
<li>+：重复一次或更多次</li>
<li>?：重复零次或一次</li>
<li>{n}：重复n次</li>
<li>{n,}：重复n次或更多次</li>
<li>{n,m}：重复n到m次</li>
</ul>

<h5>分组</h5>

<ul>
<li>(&lt;&lt; pattern &gt;&gt;)：捕获组，反向引用访问或者匹配操作的结果</li>
<li>(?:&lt;&lt; pattern &gt;&gt;)：非捕获组，不保存捕获内容</li>
</ul>

<h5>断言</h5>

<ul>
<li>(?=exp)：匹配exp前面的位置</li>
<li>(?&lt;=exp)：匹配exp后面的位置</li>
<li>(?!exp)：匹配后面跟的不是exp的位置</li>
<li>(?&lt; !exp)：匹配前面不是exp的位置</li>
</ul>

<h5>注释</h5>

<ul>
<li>(?#comment)：这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>30</wp:post_id>
		<wp:post_date><![CDATA[2017-08-16 22:48:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-08-16 14:48:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e6%80%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[416]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>2016.11.2 记一次黑客松</title>
		<link>http://bugzhang.com/?p=32</link>
		<pubDate>Wed, 02 Nov 2016 11:56:31 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=32</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/wuhackathon-head.jpg" alt="" />

<blockquote>
  <blockquote>
    10月30号到31号两天，和萌天、飞飞、zp，去武汉参加了光谷社区主办的黑客松，最后开发一个寻找周围网速最快咖啡厅的应用的想法，结合实时渲染三维地图+数据查找的应用，起名为CafeGo。
    &lt;
  </blockquote>
</blockquote>

<h2>吐槽和感想</h2>

当时天哥很忙，当时手上外包还没有结束，不过最后还是带我们去搞了。当时报名队伍很多，远远多于去年，似乎是16年开始黑客松在国内兴起的原因。安排在一个大电气厂房，并且估计是因为DHCP虚拟IP不够用的原因，一大半开发者全程没网，根本无法实现服务和查询资料。最后基本是去外边宾馆完成了。
<img src="http://7xqgks.com1.z0.glb.clouddn.com/wuhanhackerathon5.jpg" alt="" />

<blockquote>
  天哥正在调试开发，被摄影师抓拍
</blockquote>

开发过程中，发现自己在解决实际项目或者说是领域内未接触过的内容的开发时，战力基本为0，忍不住膜拜天哥的能力。
&lt;br&gt;
因为是在武汉的原因，除了武汉本地公司的程序员参加外，还有很多华科的团队参加，冰岩作坊、联创和dian这几个大牛团队都在，和中南这边的开发者相比，华科开发者能力完全不是中南所能理解（除了天哥这种个别几个强人之外）。或者说，人家看我们大概就是我们看朝鲜一样的技术。当时中南参加的除了我们，还有一些人，在我作为一个低水平web开发看来，他们做的网站难度和创意，至少前端的实现还是处于相当低级的水平（典型jQuery+bootstrap切图工）。所以在这种环境中，如果你不能像天哥那样碾压掉所有人，那么能力已经注定不会太高。
<img src="http://7xqgks.com1.z0.glb.clouddn.com/wuhanhackerathon4.jpg" alt="" />

<blockquote>
  左起是zp，天哥，我，飞哥。我当时正在讲产品。
</blockquote>

<h3>技术实现</h3>

应用服务端比较简单，采用node.js+mongodb的架构，提供RESTful的API返回json，数据库中主要包含咖啡屋地名，用户提交次数，经纬度，网速等几个字段。当客户端以发出请求后，可以响应咖啡馆的信息，客户端进行数据的解析与处理并实时渲染出所需。同事，客户端可以将自己目前的网速上传进服务器，用于数据共享，共同组建出足够大的数据库。另外，如果更新时已有数据，取最近的几个数据均值作为最终网速。

模式图如下：
<img src="http://ofu6xsokr.bkt.clouddn.com/CafeGo.png" alt="" />

客户端相对比较复杂，主要有以下解决点：

<ul>
<li>根据数据实施建模，有较好网速区分度？最后我们用绿黄红三种颜色的立体柱形外加与网速绑定的柱高来明显区分，并在旁边标注出咖啡厅名子与具体网速。</li>
<li>本地网速数据的获取与上传。</li>
<li>基于VR导航系统。</li>
</ul>

考虑到三维方面的需求和有VR功能的需求，并且要高效高速完成开发（只有不到三十小时开发）。最后决定移动客户端上，采用Unity3d完成，之后打包成为iOS与Android应用。网页端使用<a href="https://www.mapbox.com">Mapbox</a>的API完成。

<h3>效果预览</h3>

<img src="http://ofu6xsokr.bkt.clouddn.com/ALL.jpg" alt="" />

预览视频:http://v.qq.com/x/page/g0344t8vf3h.html]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>32</wp:post_id>
		<wp:post_date><![CDATA[2016-11-02 19:56:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-11-02 11:56:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[2016-11-2-%e8%ae%b0%e4%b8%80%e6%ac%a1%e9%bb%91%e5%ae%a2%e6%9d%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%89%af%e6%b7%a1"><![CDATA[扯淡]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[599]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Web性能优化分类总结</title>
		<link>http://bugzhang.com/?p=34</link>
		<pubDate>Fri, 23 Jun 2017 13:15:32 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=34</guid>
		<description></description>
		<content:encoded><![CDATA[一图流
<img src="http://img.bugzhang.com/web%E4%BC%98%E5%8C%96.svg" alt="" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>34</wp:post_id>
		<wp:post_date><![CDATA[2017-06-23 21:15:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-06-23 13:15:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[web%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e5%88%86%e7%b1%bb%e6%80%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><![CDATA[性能优化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[499]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>深信服实习面试</title>
		<link>http://bugzhang.com/?p=36</link>
		<pubDate>Wed, 05 Apr 2017 07:22:51 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=36</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0021.jpg" alt="" />

<h3>一面</h3>

1.介绍自己，介绍项目，重点介绍项目里所用技术（angular.js，vue.js，bootstrapt，npm，glup），项目过程中遇上的问题以及解决方案，因为参与开发的网站都上线运行，所以这块很顺利。

2.面试官根据简历内容提问，重点在计算机基础知识。

3.简历写了熟悉vue了解ng：询问前端三大框架对比，前端路由（vue-route）。

4.简历写了了解node和express框架：询问Node.js的异步非阻塞，牵扯到操作系统（进程线程、异步同步、阻塞非阻塞）。

5.简历写了了解nginx：说下正向代理与反向代理区别（本来知道的，当时紧张两次说成一样了，被反问后也没反应过来然后就被问了下一个）。

6.简历写了熟悉linux下开发：询问改变权限命令，具体说到421规则和RWX。

7.简历写了熟悉Git版本控制：问用的GUI还是命令行？我说命令行，询问了拉取，提交和创建分支的命令。

8.简历写了了解mongo和mysql数据库：问说明这两个数据库区别，分别适用于那种情况

9.问我专业？计算机科学与技术。学了那些课程？数据结构与算法学了吧？学了。写一个希尔排序（不会），写一个堆排序（不会），写一个快速排序。

10.TCP三次握手。

后来知道一面面试官是服务器和VPN领域比较有名的一个技术专家，写过好几本相关的书。

<h3>二面（60分钟）</h3>

一面结束后，面试官让我稍等，因为一面问题比较简单所以觉得应该能稳过。果然面试官出去大概十分钟后，二面面试官进来开始二面，期间和gay平聊了下q。

1.HTTP协议：HTTP请求头，HTTP请求方式哪几种以及区别，cookie在哪里，什么特点，服务器那边对应的是什么，除了cookie还有那些常见的客户端存储。HTTP相应头，状态码。

2.HTTPS协议：说完SSL与TLS后自己又拓展把细节介绍了下，对称密钥与非对称密钥，https优缺点，https证书cname配置。

3.background实现一个简单效果，我一直试图用svg和iconfont实现，后来才知道人家只问background，然后我解释用svg和iconfont可以减少请求与大小优化性能

4.盒子模型，margin负值实现简单效果，position属性

5.水平垂直居中一个div。

6.三栏布局，我说了flex布局然后拓展说了bootstrapt的原理（3代以前媒体查询+浮动+绝对定位，四代开始用flex）

7.js基本类型，说完六种后我说还有symbol，常见的引用类型

8.Array api

9.dom实际操作：生成子元素并赋予id，修改css，删除一些节点等等类似简单问题

10.看到我会数据库，打算让我设计一个系统的数据库，因为我怕被问到不擅长的地方，直接说不是很擅长数据库设计，然后他给我画了几张表。问我相关sql语句。

11.一个页面到一个数据库中间会发生一种安全隐患，是什么：sql注入，解决方案转义、存储过程、检查类型，危害。又告诉他xss也可以被发生，只要有input就可以xss，之后介绍xss分类，解决方案与危害13.因为xss说道跨域，解释了游览器同源策略，前端跨域解决方案，cors，jsonp，图像p

12.你的数据库经常用的什么做主键？自增。我指的是数据类型？Number，我用mongo。会关系型吧？会，mysql用int之类，和number一样的。连外键后主键冲突怎么解决？uuid()，mongo有默认主键_id不会冲突，生成和时间进程机器有关。

13.用什么游览器？chrome。调试怎么调试？console.log和断点具体细节以及为何不用alert。有没有用过抓包工具？没有用过专门的，前端性能优化靠chrome自带的开发者工具就够了

<h3>三面（20分钟）</h3>

十几分钟后，一面面试官回来，告诉我还有一个三面，三面是深圳那边电面，明天早上来电话。
一早上没来电话，下午三点我在实验室沙发睡觉，来了一个深圳电话，晕晕乎乎接了电话，面试官解释早上有些忙不好意思，我同时找眼镜找了半天最后还是没找到（八百度近视的我只有和我差不多的人才能体会不戴眼镜的痛苦）。开始三面，从自我介绍开始一直卡到项目介绍。好在问的很水。

1.自我介绍

2.项目介绍，技术选型，上线了没，现在就能访问，给了地址

3.你大三实习不方便吧，能解决不

4.感觉你对新技术关注度很高，技术选型比较新，平时怎么学这些，上那些网站，看了那些书，网站关于什么，书关于什么

5.写博客么？我给了我博客地址，写了多少篇？从15年1月写到现在，大概30多篇。自己写的还是的转载别人的？有一些是学习笔记，大多数是算自己写的吧。

6.参与过开源项目么，没有。虽然我有四年使用的github，但只是作为个人项目的一个代码托管工具以及方便部署项目，目前技术太水没有做开源的能力，以后有能力会尽量参与。

7.聊人生

8.怎么知道公司的

9.有没有其他问题问他]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>36</wp:post_id>
		<wp:post_date><![CDATA[2017-04-05 15:22:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-04-05 07:22:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b7%b1%e4%bf%a1%e6%9c%8d%e5%ae%9e%e4%b9%a0%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
		<category domain="post_tag" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[844]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[101.41.1.181]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-12-24 21:59:25]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-12-24 13:59:25]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[看着这篇文章跟我当时去360面试时一模一样，尴尬 :grin:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[bugzhang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[i@bugzhang.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.246.229.110]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-12-25 18:45:46]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-12-25 10:45:46]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我360面试是真的难，二面被怼惨了。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>4</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810659.5629859;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810752.3059809;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551861811.1001711;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628000.128547;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628306.5464411;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					</item>
					<item>
		<title>重绘和回流</title>
		<link>http://bugzhang.com/?p=38</link>
		<pubDate>Thu, 11 May 2017 14:39:56 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=38</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0023.jpg" alt="" />

<h3>游览器渲染过程</h3>

渲染过程发生在通过http得到资源后的游览器内部，其过程如下：
<img src="http://7xqgks.com1.z0.glb.clouddn.com/domRender.png" alt="" />

<ul>
<li>游览器首先对HTML进行解析，这部分由游览器的HTML文档引擎实现，如KHTML（其细节与原理以后有时间会分析源码后再写一篇），这时得到dom元素并生产DOM树（dom tree），每一个HTML标签&lt;Tag&gt;都会在DOM树有对应的节点，根节点就是document对象，对应&lt;html&gt;&lt;/html&gt;元素。</p></li>
<li><p>于此同时，游览器会对CSS进行解析，其解析优先级为：以style属性书写的CSS -&gt; 用户link引入的CSS -&gt; 用户import引入的CSS -&gt; 游览器默认的CSS规则，并且考虑CSS覆盖于优先级，忽略不能被解析的错误CSS与无意义的前缀名，保留有意义的可被正确解析的CSS。</p></li>
<li><p>CSS解析完毕后，通过之前生成的渲染树加上解析完毕后的CSS，就能构建一课渲染树（render tree），每一个元素一般会对应一个节点，不一般的情况大家也能想到就是通过<code>display:none</code>进行修饰的元素就不会出现先渲染树中（敲黑板：因此也就不会有物理空间了，笔试常考），以及某些可以换行的块级元素<code>&amp;lt;p&amp;gt;</code>是一行一个节点。</p></li>
<li><p>完成渲染树后，游览器开始绘制页面。</p></li>
</ul>

<hr />

<h3>重绘和回流</h3>

<ul>
<li>重绘：当渲染树中的元素样式改变<strong>不影响</strong>布局时，发生重绘，重绘不会改变整课渲染树，只会改变部分渲染树的节点属性，如颜色，风格，字体样式，阴影，模糊，背景等。</li>
<li>回流：当渲染树种元素的样式改变<strong>影响了</strong>布局时，发生回流，回流会让页面重新构造，并让受到影响的部分失效，完成回流后，游览器会重新展示受影响的部分，这个过程也是重绘。所以发生回流是一定会发生重绘的。引起回流的样式改变有：

<ul>
<li>添加或删除可见的dom元素；</li>
<li>修改了可见dom元素的大小、位置、布局、隐藏（<code>display:none</code>会回流，<code>visibility: hidden</code>不会回流）；</li>
<li>修改了可见元素的内容，需要重新计算，如改变图片的src，改变文字的数量；</li>
<li>游览器的窗口变化，改变缩放比例，改变字号，滚动；</li>
<li>页面渲染初始化；</li>
<li>添加了一个样式表其中有引起回流的样式;</li>
</ul></li>
</ul>

<hr />

<h3>前端优化之减少重绘与回流</h3>

<p>通过上面分析，已经熟悉了重绘与回流的概念和过程，那么其优化无非就是减少引起重绘和回流的样式改变。

<ul>
<li>使用改变类名的方式改变样式，可以一次性将多个样式改变，从而减少重绘和回流的产生次数，同时也增加了页面的可维护性。</li>
<li>使用<code>display:none</code>隐藏元素</li>
<li>尽量不要计算元素</li>
<li>能用重绘解决的就不要用回流解决</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>38</wp:post_id>
		<wp:post_date><![CDATA[2017-05-11 22:39:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-05-11 14:39:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%87%8d%e7%bb%98%e5%92%8c%e5%9b%9e%e6%b5%81]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="css"><![CDATA[CSS]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><![CDATA[性能优化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[505]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>使用gulp减少HTTP请求</title>
		<link>http://bugzhang.com/?p=40</link>
		<pubDate>Sun, 18 Jun 2017 14:42:56 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=40</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0026.jpg" alt="" />

<blockquote>
  游览器与服务器每进行一个http连接，需要进行TCP三次握手的确认，如果是https更是多出了7次安全确认来完成连接。每个http报文中，又有很多重复的多余信息，因此减少http请求，是最为可行的前端优化方式之一。以下是现代前端中，常用的减少http请求的方式及其实现。
</blockquote>

<h3>CSS Sprites</h3>

CSS Sprites，又叫雪碧图或者CSS精灵，是指把多个图片合并在一张图片上，然后通过<code>background-positon</code>属性制定CSS prites偏移量。
因为实现很简单，这个就不粘代码了。&lt;br&gt;
总之雪碧图可以让项目变得：更少的图片，干净的标签，更少的HTTP请求，甚至更小的文件（因为图片压缩编码的原因，合并后的文件往往比分开的文件总和要小，空白区域并不会增加额外的大小）。总而言之使用CSS Sprites可以提升网站性能。

<h3>合并js脚本与css样式表</h3>

每多合并一个js脚本或者css样式表，就可以减少一次http请求，进而提升性能。对于现代前端而言，合并脚本与样式表的工作，往往交给自动化工具完成，我常用的是Gulp，下边是使用Gulp自动化工具进行压缩的配置文件gulpfile.js的示例：

<pre><code class="javascript">const gulp = require('gulp');
const concat = require('gulp-concat');
const concatCss = require('gulp-concat-css');

gulp.task('testConcat', function () {
    gulp.src('src/js/*.js')
        .pipe(concat('main.js'))        //合并后的文件名
        .pipe(gulp.dest('dist/js'));
});

gulp.task('testConcatCss', function () {
  return gulp.src('assets/**/*.css')
    .pipe(concatCss("styles/bundle.css"))
    .pipe(gulp.dest('out/'));
});
</code></pre>

附gulp中文文档：<a href="www.gulpjs.com.cn">www.gulpjs.com.cn</a>

<h3>将小图片进行base64编码后写入css</h3>

用编码工具，将小图片进行base64编码，然后将编码后的数据拷贝出来，放在background-image: url的位置。该方法也同样减少了http请求，但会增大体积，故不适合于大图片仅适合于小图片。实现同样很简单，就不写了。

<h3>采用icon-font的方式引入矢量图标</h3>

实现很简单，把svg丢到一个自动化的工具里就可以打包出来了，使用通过css的类来使用，相信用过bootstrap等此类响应式框架的同学都知道。我常用的打包网站是：https://icomoon.io/ 。个人感觉，这是最适合的对图片的处理方式，未来小图片将全部矢量化。
&lt;br&gt;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>40</wp:post_id>
		<wp:post_date><![CDATA[2017-06-18 22:42:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-06-18 14:42:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8gulp%e5%87%8f%e5%b0%91http%e8%af%b7%e6%b1%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96"><![CDATA[前端工程化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[464]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>使用Web Worker</title>
		<link>http://bugzhang.com/?p=42</link>
		<pubDate>Wed, 28 Jun 2017 14:48:00 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=42</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0022.jpg" alt="" />

<blockquote>
  js作为单线程的语言，无法同时运行多个处理程序，但面对一些不得不耗费资源才能完成的任务时，单线程弊端就显现出来，为了解决这个问题，Wob Worker应身而出：“Worker”是指执行代码的并行线程，可以在一个不与用户交互的独立环境中，就行一些耗资源任务的处理，与游览器文档中的js相当于多线程，比如图像处理等任务。Web Worker有效解决了js的缺点，同时是提升性能的一个方法之一：将耗资源的代码在worker中执行。
</blockquote>

<h3>worker对象</h3>

<pre><code>//创建worker对象并执行
var worker = new Worker("js/decrypt.js");

//添加事件处理程序，完成后给主线程发送信息时执行
worker.onmessage = function(e){
    console.log('finash');
}

//发送信息给worker
worker.postMessage('file.txt');

//注册用来接收来自主线程信息的处理程序
worker.onmessage = function(e){
    //从事件对象获取消息
    var valueToDecrypt = e.data;
    //进行操作
    console.log('end');
    //返回给主线程
    postMessage(decryptedValue);
}
</code></pre>

<h3>Worker执行模型与作用域</h3>

Worker线程从上到下执行代码与文件，如果Worker注册了onmessage事件，只要message事件可能触发，将永远不会退出。
一个Worker对象是运行在完全隔离的环境中，其作用域大于主线程所在的JavaScript全局对象，小于整个客户端的Window对象。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>42</wp:post_id>
		<wp:post_date><![CDATA[2017-06-28 22:48:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-06-28 14:48:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8web-worker]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96"><![CDATA[前端优化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[366]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript模块化</title>
		<link>http://bugzhang.com/?p=44</link>
		<pubDate>Mon, 14 Aug 2017 14:53:07 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=44</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0029.jpg" alt="" />

<h3>从古代前端说起</h3>

早起的前端，是没有工程体系的，基本就是div+css，以及用js做个动画验证个表单之类的工作，因为工程不复杂，变量少，代码重构难度低，开发团队也不大（当时很多前端都是后端甚至设计师来写），所以这门语言一开始对模块化的需求不大，可以统统全局变量，反正没几个。在需要的时候写端脚本然后引入即可，甚至很多js代码是混入html属性中也不足为奇。

<h3>模块</h3>

模块表示一个大的结构中的小部门活着组建，常说的代码模块也大概如此，而对于javascript来说，模块代表就是一个特定函数。

<pre><code class="javascript">var module =
(function() {
    //私有变量 函数
    ...
    return{
    //公有函数
    ...
    };
})();
</code></pre>

这种javascript模块，将内部功能与对外功能划定了清晰的界限。防止了命名冲突。

<h3>CommonJS</h3>

CommonJS认为js不应该只是简单脚本语言，应该可以运行在任何地方，因此开始制定一系列api。CommonJS的崛起主要是随着node.js的大热，而被熟知了的。

<pre><code class="javascript">//定义模块
exports.sum = {};

//使用模块
var xxx = require('xxx');
exports.add = function(n){
     return xxx.ss(val,n);
};
</code></pre>

这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快。但是如果在客户端，加载模块的时候有可能出现“假死”状况。因为使用时候必须等模块加载完毕。但即使如此，实际还是不能使用的主要原因是少了node中才有的几个全局变量：

<ul>
<li>module</li>
<li>exports</li>
<li>require</li>
<li>global</li>
</ul>

现在，browserify和webpack，通过commonjs在游览器的实现，可以进行模块打包处理，其中webpack已经成为了前端工程标准的打包工具。

<h3>AMD</h3>

AMD，即 (Asynchronous Module Definition)，异步模块定义，require.js应用的是这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行。

<pre><code class="javascript">//使用模块
require([module], callback);
</code></pre>

<h3>CMD</h3>

CMD， Common Module Definition，命令模块定义。实现是淘宝玉伯大神开发的sea.js相关的。
CMD和AMD一样也是异步的，其使用方式是：

<pre><code class="javascript">//模块的定义
define(function(require, exports, module) {
   var xxx = require('xxx');
   xxx.start();
});
</code></pre>

AMD和CMD最大的区别是对依赖模块的执行时机处理不同。
CMD对模块的态度是懒执行, 而AMD对模块的态度是预执行。CMD是在需要的时候才会执行，带来的好处就是开发者能理解因为过程更接近与人脑所想，而AMD是所有的模块全部提前，带来结果就是如果不考虑这点就会被坑。可以说CMD通过机器打包的效率提升了编码效率，这可能也是sea.js在webpack但是之前在国内更火的原因。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>44</wp:post_id>
		<wp:post_date><![CDATA[2017-08-14 22:53:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-08-14 14:53:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e6%a8%a1%e5%9d%97%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96"><![CDATA[前端工程化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[404]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Webpack构建原理</title>
		<link>http://bugzhang.com/?p=52</link>
		<pubDate>Sat, 19 Aug 2017 10:09:08 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=52</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0037.jpg" alt="" />
<img src="https://sfault-image.b0.upaiyun.com/307/325/3073259919-576944e693dc3_articlex" alt="" />
现代前端工程化：ES6 + Webpack + React + Babel，commonjs 的模块必须在使用前经过 webpack 的构建才可以被游览器直接使用，webpack是现代前端重要一环。

<h3>webpack解决的问题</h3>

当项目很复杂的时候，没有模块系统会产生很多复杂问题，模块化相关如下：http://bugzhang.com/2017/08/01/javascriptmo-kuai-hua/
webpack可以打包所有静态资源，常见的例如：

<ul>
<li>根据模板生成html,并且自动处理上面的css/JS引用路径</li>
<li>自动处理img里图片路径，css样式中背景图的路径，字体引用</li>
<li>开启本地服务器，变写代码边自动更新页面内容watch</li>
<li>编译jsx、es6、sass、less、coffeescript等等并添加md5、sourcemap等辅助</li>
<li>异步加载内容，比如弹出框，不需要时不加载到dom</li>
<li>配合vue.js、react等框架，解析相关文件
<img src="http://webpack.github.io/assets/what-is-webpack.png" alt="" /></li>
</ul>

<h3>webpack整体架构</h3>

以webpack.config主要部分划分，webpack主要有以下部分：

<ul>
<li>entry：一个可执行模块的入口文件</li>
<li>output：模块的出口目录</li>
<li>chunk：多个文件组成的一个代码块</li>
<li>loader：模块转换器，确定处理方式</li>
<li>plugin：插件，拓展webpack功能，与loader一同定义webpack的处理方式</li>
</ul>

<pre><code class="javascript">module.exports = {
  devtool: isProd
    ? false
    : '#cheap-module-source-map',
  output: {
    path: path.resolve(__dirname, '../dist'),
    publicPath: '/dist/',
    filename: '[name].[chunkhash].js'
  },
  resolve: {
    alias: {
      'public': path.resolve(__dirname, '../public')
    }
  },
  module: {
    noParse: /es6-promise\.js$/, // avoid webpack shimming process
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueConfig
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/
      },
      {
        test: /\.(png|jpg|gif|svg)$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: '[name].[ext]?[hash]'
        }
      },
      {
        test: /\.css$/,
        use: isProd
          ? ExtractTextPlugin.extract({
              use: 'css-loader?minimize',
              fallback: 'vue-style-loader'
            })
          : ['vue-style-loader', 'css-loader']
      }
    ]
  },
  performance: {
    maxEntrypointSize: 300000,
    hints: isProd ? 'warning' : false
  },
  plugins: isProd
    ? [
        new webpack.optimize.UglifyJsPlugin({
          compress: { warnings: false }
        }),
        new ExtractTextPlugin({
          filename: 'common.[chunkhash].css'
        })
      ]
    : [
        new FriendlyErrorsPlugin()
      ]
}
</code></pre>

<blockquote>
  一个典型的webpack配置文件
</blockquote>

<h3>webpack构建过程</h3>

官网对webpack构建的图示如下：
<img src="https://segmentfault.com/img/remote/1460000004839887" alt="" />
webpack会将所有静态资源看做是模块，然后把这些模块组成到一个bundle，在页面上最终引入一个bundle.js实现对静态资源的加载。大概过程如下：
<img src="https://segmentfault.com/img/remote/1460000005770047" alt="" />

构建过程中，webpack做了很多工作，主要的有：

<ul>
<li>读取并初始化option</li>
<li>编译</li>
<li>递归分析依赖，按照依赖build</li>
<li>构建，构建过程中会用相应的loader</li>
<li>构建完毕后编译，生成AST抽象语法树</li>
<li>遍历AST，在有依赖时，收集依赖</li>
<li>打包前合并、压缩等</li>
<li>输出文件</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>52</wp:post_id>
		<wp:post_date><![CDATA[2017-08-19 18:09:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-08-19 10:09:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[webpack%e6%9e%84%e5%bb%ba%e5%8e%9f%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96"><![CDATA[前端工程化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[670]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>CVTE与有赞面试</title>
		<link>http://bugzhang.com/?p=56</link>
		<pubDate>Mon, 28 Aug 2017 15:11:55 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=56</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0038.jpg" alt="" />

<h3>有赞面试（85分钟）</h3>

晚上八点，正在睡觉，我一般有晚上或者傍晚睡一小会觉的习惯，因为晚上睡得晚。接到一个浙江杭州的电话，这是第二次打给我，第一次也是在睡觉没听到电话。迷迷糊糊中接到电话，面试官一开始和我说有没有时间，考虑到两天前就没有接到电话，所以就没好意思推，于是说有时间，面试官让加qq然后开始视频面。

1.项目。
2.说一说闭包。闭包优缺点。看你用过vue.js，讲讲闭包在vue源码哪里用过。
3.盒子模型。哪个css可以改变盒子模型。这时候面试官让我打开codepen，开始需要把后边的代码写出来
4.水平居中，垂直居中，水平垂直居中。
5.flex布局。写justify-content写到just后边的忘了怎么拼，然后解释代码补全用习惯了，尴尬。
6.positon取值，讲讲sticky。
7.display取值，元素默认的什么，内联元素块级元素可变元素有那些？img是什么的？
8.float：left情况下是怎样的，此时如果超出了宽度范围。
9.CSS3的transform。
（好吧，我来问你一些js的东西）
10.输入一个url后发生了什么。
11.tcp协议，http协议
12.写继承，不能用class...entend。
13.写快速排序。
14.写一个js判断全等的方法。

一面挂。主要是基础不牢固外加当时刚睡醒大脑没反应，所以本来很基础的面试答得很差。面试官人很好，中途引导，学到很多东西。

<h3>CVTE面试（60分钟）</h3>

本来不太考虑cvte的，因为已经拿了个同档公司的，不过后来听在cvte实习的同学说cvte用react，想想写react还是比较爽的，所以就让同学内推了下，和面试官预约时间聊了聊。

1.项目。
2.前端优化。
3.前端安全。
4.v-dom。单向数据流与绑定的优缺点。
5.游览器缓存机制。
6.get，post区别。ajax过程。
7.js内存管理机制。内存泄漏咋解决。
8.自己写的组件是如可设计的，prop和state怎么设计，区别是啥。
9.前端路由实现方案，react-route是咋实现的。
10.事件代理，原理，冒泡与捕获区别。
11.this指向。
12.最近关注点。聊了PWA，小程序。
13.用Node写过什么，写过一个Mock数据的工具，打算上传npm包，也用过express和egg但还不是很熟练。用了哪些原生node的包，http，fs，path等等这些你说的包是做啥的。
15.聊聊自己对前端看法，我说我比较做面向管理人员的前端，因为不需要考虑兼容性，而且能用最新技术。此外我不喜欢写css所以不喜欢写面向用户的前端。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>56</wp:post_id>
		<wp:post_date><![CDATA[2017-08-28 23:11:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-08-28 15:11:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[cvte%e4%b8%8e%e6%9c%89%e8%b5%9e%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
		<category domain="post_tag" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1196]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>深入理解Vitual DOM</title>
		<link>http://bugzhang.com/?p=58</link>
		<pubDate>Tue, 29 Aug 2017 15:12:57 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=58</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0049.jpg" alt="" />

<blockquote>
  Vitual DOM是被诸如React,Vue,Preact等框架采用的一种内部黑盒技术，用来作为到最终dom操作的一个中介。
  <img src="http://7xqgks.com1.z0.glb.clouddn.com/v-dom1.png" alt="" />
  v-dom在前端的工作图
</blockquote>

<h3>v-dom是什么</h3>

v-dom是一个真实dom的模拟表示，它像是原始dom的一个轻量级的副本，不同的是v-dom减少了冗余，采用了高性能的diff算法比较更新dom，同时只通过最终的正式dom操作来渲染入游览器，这最终特性保证了v-dom的高效。

<h3>为什么要用v-dom</h3>

DOM操作是把js实现到游览器的核心，一切的交互都需要用过dom。不幸的是，don操作是一件性能非常底下的工作：因为dom对象中有很多和操作无关的冗余字段，而任何dom操作不得不遍历整颗冗余度非常高的dom树。

比如，目前有一个列表，包含多个项目，当检查第一项，dom将重建整个列表，这是十倍以上的非必须工作，在早起前端，因为业务的不复杂性，dom操作尚能工作顺利，但目前越来越复杂的前端场景，现代网站可以使用大量dom操作，低效更新已经是一个严重的问题。

<img src="http://7xqgks.com1.z0.glb.clouddn.com/v-dom2.png" alt="" />真实的游览器渲染过程，元素的更新会涉及到重绘和回流，进一步降低性能。

这种缓慢的现实，使得很多js框架采用自己的方式去更新dom，v-dom就是其中一个被推广的佼佼者。

<h3>v-dom如何被建立</h3>

<img src="http://efe.baidu.com/blog/the-inner-workings-of-virtual-dom/1.png" alt="" />Preact的dom工作流程。

<h5>虚拟元素</h5>

我们可以用如下的虚拟元素替代真实dom：

<pre><code class="javascript">/**
 * 一个类似的dom结构元素的v-dom设计
 * &lt;div id="container"&gt;
 *  &lt;h1&gt;Hello v-dom&lt;/h1&gt;
 * &lt;/div&gt;
 */

var element = {
    tagName: 'div',
    attr: {
        props: {
            id: 'container'
        },
        style: {
            color: 'black'
        }
    },
    children: {
        tagName: 'h1',
        value: 'Hello v-dom'
    }
}

//用构造函数模拟一下
function Element(tagName, attr, children, value) {
    this.tagName = tagName;
    this.attr = attr;
    this.children = children;
    this.value = value;
};
var headline = new Element('h1', null, null, 'Hello world');
var container = new Element('div', {
    props: {
        id: 'container'
    },
    style: {
        color: 'black'
    }
}, headline, null);
</code></pre>

上述代码就是一个对v-dom的描述以及简单实现，实际上React的JSX转换后真正调用的API也是类似的API，这个API是<code>React.createElement()</code>。

v-dom有一些通用的特点：轻量级、无状态、不可改变。

<h5>render方法</h5>

有了上述的v-dom对象后，再通过类似<code>render()</code>的方法，就可以创建真实dom，render函数的简单实现类似这样：

<pre><code class="javascript">function render(element, root) {
    var realDOM = document.createElement(element.tagName);
    //循环设置属性和样式
    var props = element.attr.props;
    var styles = element.attr.style;
    for (var i in props) {
        realDOM.setAttrbute(i, props[i]);
    }
    for (var j in styles) {
        realDOM.style[j] = styles[j];
    }
    //循环子节点，如果是对象递归该方法，否则创建文本节点
    element.children.forEach(function (child) {
        if (child instanceof Element) {
            render(child, realDOM);
} else {  
            raedlDOM.appendChild(document.createTextNode(child));
        }
    });
    //插入真实dom
    root.appendChild(realDOM);
    return realDOM;
}
</code></pre>

<h5>diff算法比较差异</h5>

当Virtual DOM发生更新时候，会进行变化生成一颗新的dom树，为了比较两棵树的异同，引入了一种Diff算法完成比较，diff算法非常高效，当对v-dom完成差异比较后，这个差异会作用到真实dom，过程如下：

<ul>
<li>1.构建Virtual Dom树</li>
<li>2.将Virtual Dom插入真实dom</li>
<li>3.构建变化后的Virtual Dom树</li>
<li>4.通过diff算法比较差异</li>
<li>5.仅将差异在真实DOM中更新</li>
</ul>

给定任意两颗树，进行转换的差异算法，一般复杂度是O(n^3)，react的diff算法复杂度是O(n)，它基于v-dom的两个基本事实：

<ul>
<li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li>
<li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li>
</ul>

组件的树是自带层级的，diff算法按照层级比较，如图：
<img src="http://cdn.infoqstatic.com/statics_s2_20170822-0429/resource/articles/react-dom-diff/zh/resources/0909000.png" alt="" />
如果节点类型不同，直接删除Before中的节点，插入新节点；如果节点类型相同，继续层序遍历属性，属性不同则替换属性；直到遍历到最底层。通过一次遍历，即可比较出不同，更新了整个dom。

<pre><code class="javascript">//一个参考算法，链接：https://www.zhihu.com/question/29504639/answer/73607810
// diff 函数，对比两棵树
function diff (oldTree, newTree) {
  var index = 0 // 当前节点的标志
  var patches = {} // 用来记录每个节点差异的对象
  dfsWalk(oldTree, newTree, index, patches)
  return patches
}

// 对两棵树进行深度优先遍历
function dfsWalk (oldNode, newNode, index, patches) {
  // 对比oldNode和newNode的不同，记录下来
  patches[index] = [...]

  diffChildren(oldNode.children, newNode.children, index, patches)
}

// 遍历子节点
function diffChildren (oldChildren, newChildren, index, patches) {
  var leftNode = null
  var currentNodeIndex = index
  oldChildren.forEach(function (child, i) {
    var newChild = newChildren[i]
    currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识
      ? currentNodeIndex + leftNode.count + 1
      : currentNodeIndex + 1
    dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点
    leftNode = child
  })
}
</code></pre>

一篇很好的diff算法原理的解析：http://www.infoq.com/cn/articles/react-dom-diff/

<h3>生命周期问题</h3>

v-dom的整个过程，即产生了生命周期，一切和v-dom相关的组件的生命周期也与之相关。如：

<img src="https://cn.vuejs.org/images/lifecycle.png" alt="" />vue组件的生命周期
<img src="http://7xqgks.com1.z0.glb.clouddn.com/3-3-component-lifecycle.jpg" alt="" />react组件的生命周期

一般分为初始化、运行中、销毁三个状态，三个状态有关的生命周期钩子函数有：

<strong>初始化阶段</strong>：

　　getDefaultProps:获取实例的默认属性(即使没有生成实例，组件的第一个实例被初始化CreateClass的时候调用，只调用一次,)

　　getInitialState:获取每个实例的初始化状态（每个实例自己维护）

　　componentWillMount：组件即将被装载、渲染到页面上（render之前最好一次修改状态的机会）

　　render:组件在这里生成虚拟的DOM节点（只能访问this.props和this.state；只有一个顶层组件，也就是说render返回值值职能是一个组件；不允许修改状态和DOM输出）

　　componentDidMount:组件真正在被装载之后，可以修改DOM

<strong>运行中状态</strong>：

　　componentWillReceiveProps:组件将要接收到属性的时候调用（赶在父组件修改真正发生之前,可以修改属性和状态）

　　shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）

　　componentWillUpdate:不能修改属性和状态

　　render:只能访问this.props和this.state；只有一个顶层组件，也就是说render返回值只能是一个组件；不允许修改状态和DOM输出

　　componentDidUpdate:可以修改DOM

<strong>销毁阶段</strong>：

　　componentWillUnmount:开发者需要来销毁（组件真正删除之前调用，比如计时器和事件监听器）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>58</wp:post_id>
		<wp:post_date><![CDATA[2017-08-29 23:12:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-08-29 15:12:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3vitual-dom]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82"><![CDATA[前端底层]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[472]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Zepto源码分析——Zepto核心</title>
		<link>http://bugzhang.com/?p=62</link>
		<pubDate>Mon, 11 Sep 2017 03:16:07 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=62</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0046.jpg" alt="" />

<h2>前言</h2>

一直计划想写一写某个框架的源码分析，之前读过jQuery的，但感觉jQuery太大，同时网上研究也已经很多而且很全了，所以选取迷你版jQuery之称的Zepto作为分析对象，边读边写，同时司徒正美大神的《JavaScript框架设计》这本书的对js框架的讲解，来写写自己理解。

<h2>目录结构</h2>

源码下载地址：https://github.com/madrobby/zepto ，源码在src目录下，目录结构如下：

<pre><code>├── src
   ├── ajax.js
   ├── amd_layout.js
   ├── assets.js
   ├── callbacks.js
   ├── data.js
   ├── deferred.js
   ├── detect.js
   ├── event.js
   ├── form.js
   ├── fx.js
   ├── fx_methods.js
   ├── gesture.js
   ├── ie.js
   ├── ios3.js
   ├── selector.js
   ├── stack.js
   ├── touch.js
   └── zepto.js
</code></pre>

<h2>命名空间</h2>

<pre><code class="javascript">var Zepto = (function() {
  return $
})()

window.Zepto = Zepto
window.$ === undefined &amp;&amp; (window.$ = Zepto)
</code></pre>

Zepto借鉴了类似jQuery的挂载全局变量的方式实现，核心是返回$传递给Zepto。然后把Zepto和$作为window的属性。这样不会发现变量冲突，即使冲突只需要修改这两个变量名。
此外补充下，因为很多框架都采用了$作为标配，因此经常会出现$这个变量名冲突的问题，不过一般情况下Zepto是不会和jQuery冲突（这两个只选取一个就足够了），jQuery中的解决方案是：

<pre><code class="javascript">//先把可能存在的变量名存放
var _jQuery = window.jQuery,
    _$ = window.$;

//没冲突时候放进去
jQuery.extend({
  noConflict:function(deep){
    window.$ = _$;
    if(deep){
      window.jQuery = _jQuery;
    }
    return jQuery;
  }
});
</code></pre>

<h2>类型判定</h2>

这段代码是相对比较简单的，就不再复习一遍JavaScript的类型了。直接上代码：

<pre><code class="javascript">function type(obj) {
  return obj == null ? String(obj) :
    class2type[toString.call(obj)] || "object"
}

function isFunction(value) {
  return type(value) == "function"
}

function isWindow(obj) {
  return obj != null &amp;&amp; obj == obj.window
}

function isDocument(obj) {
  return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE
}

function isObject(obj) {
  return type(obj) == "object"
}

function isPlainObject(obj) {
  return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype
}

function likeArray(obj) {
  var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length,
    type = $.type(obj)

  return 'function' != type &amp;&amp; !isWindow(obj) &amp;&amp; (
    'array' == type || length === 0 ||
    (typeof length == 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj)
  )
}
</code></pre>

JavaScript的类型判断有一些坑，如下：

<pre><code class="javascript">//type的坑
typeof null // 'object'
typeof document.childNodes  //safari 'function'
typeof document.createElement('embed')  //firefox3-10  'function'
typeof document.createElement('object')  //firefox3-10  'function'
typeof document.createElement('applet')  //firefox3-10  'function'
typeof /\d/i  //  'function'
typeof window.alert  //ie6-8  'object'
//跨文档比较原型，会不一致
var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length - 1].Array;
var arr = new xArray[1,2,3];
arr instanceof Array;   //false
arr.constructor === Array;  //false
//旧版本AE中DOM和BOM对象的constructor不存在
window.onload = function(){
    alert(window.constructor);  //ie67 undefined
    alert(document.constructor);  //ie67 undefined
    alert(document.body.constructor);  //ie67 undefined
    alert((new ActiveXObject('Microsoft.XMLHTTP')).constructor);  //ie6-9 undefined
}
//isNaN会把字符串、数组放回去返回true
isNaN('aaa')  //true
</code></pre>

<h2>框架入口</h2>

<pre><code class="javascript">  zepto.init = function(selector, context) {
    var dom
    // 如果没有选择器，返回一个空Zepto对象
    if (!selector) return zepto.Z()
    // 如果是字符串类型的选择器
    else if (typeof selector == 'string') {
      // 去除收尾空白符
      selector = selector.trim()
      // 如果传入的字符串是以&lt;开头且符合HTML代码规则，创建元素
      if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector))
        dom = zepto.fragment(selector, RegExp.$1, context), selector = null
      // 如果不是规范但又有内容，在指定位置查找
      else if (context !== undefined) return $(context).find(selector)
      // 如果是CSS选择器，调用CSS选择器查找
      else dom = zepto.qsa(document, selector)
    }
    // 如果是函数，当dom创建时调用
    else if (isFunction(selector)) return $(document).ready(selector)
    // 如果是一个Zepto对象，直接返回这个对象
    else if (zepto.isZ(selector)) return selector
    else {
      // 如果是数组，转成类数组对象
      if (isArray(selector)) dom = compact(selector)
      // 如果是一个对象，将其包括到一个数组中
      else if (isObject(selector))
        dom = [selector], selector = null
      // 如果是HTML片段，以此创建节点
      else if (fragmentRE.test(selector))
        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null
      // 如果有context参数，在context上创建
      else if (context !== undefined) return $(context).find(selector)
      // 如果是CSS选择器，调用CSS选择器查找
      else dom = zepto.qsa(document, selector)
    }
    // 从查找到的节点创建一个Zepto对象
    return zepto.Z(dom, selector)
  }
</code></pre>

一个基本概念就是Zepto对象，Zepto是一个类数组对象，它具有链式方法来操作它指向的DOM节点，除了$(Zepto)对象上的直接方法外(如$.extend)，文档对象中的所有方法都是集合方法。

调用Zepto框架的方法，都是作用于Zepto()对象的，init函数所做的工作就是讲正常的DOM对象转换成具有Zepto方法的Zepto对象。

<h2>对象拓展</h2>

对象拓展是一种机制，用来把新功能添加到命名空间上。实质就是深浅拷贝。
<code>javascript
function extend(target, source, deep) {
  for (key in source)
    if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) {
      if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))
        target[key] = {}
      if (isArray(source[key]) &amp;&amp; !isArray(target[key]))
        target[key] = []
      extend(target[key], source[key], deep)
    }
  else if (source[key] !== undefined) target[key] = source[key]
}</code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>62</wp:post_id>
		<wp:post_date><![CDATA[2017-09-11 11:16:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-11 03:16:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zepto%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-zepto%e6%a0%b8%e5%bf%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="zepto-js"><![CDATA[zepto.js]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><![CDATA[源码分析]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[378]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>关于我</title>
		<link>http://bugzhang.com/?p=74</link>
		<pubDate>Wed, 23 Dec 2015 15:34:28 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=74</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0058.jpg" alt="" />

<h1>Who am I ?</h1>

我是Bugzhang

95年出生

来自西北甘肃武威，目前在深圳工作

web全栈工程师

从事web开发接近2年

毕业于中南大学计算机系

<h1>What do I write ?</h1>

<ul>
<li>生活点滴</li>
<li>学习经验</li>
<li>个人心得</li>
</ul>

所以大部分会是流水账式的烂文

<h1>What can I do ?</h1>

<strong>√=掌握技能</strong>  <strong>o=熟练技能</strong> <strong>#=入门技能</strong>
- 计算机网络  √
- 操作系统  √
- 数据结构和算法  √
- 信息安全  √
- html/css/js   √
- node.js  √
- egg.js √
- vue  √
- webpack  √
- webkit  √
- mysql  √
- react   √
- 编译原理  o
- angular o
- golang  o
- AE/final cut pro   #
- PS/Sketch   #

<h1>How to contact me ？</h1>

评论：可以评论任意博客内容联系我:

E-mail：nuptunee@gmail.com]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>74</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 23:34:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-23 15:34:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e6%88%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1588]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>一些链接</title>
		<link>http://bugzhang.com/?p=76</link>
		<pubDate>Wed, 23 Dec 2015 15:42:48 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=76</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Nodex's Hackers：</h1>

<h3><a href="http://www.justzht.com">JustZht：天哥，iOS，也写unity，在中南最佩服的人，目前准备留美学习中</a></h3>

<h3><a href="http://blog.x-fei.me/">飞飞 : 大学好友，目前在中山大学读硕士做CV</a></h3>

<h3><a href="https://github.com/nerososft">neroyang：高中学弟，锋哥，全栈，C++/Java/PHP/js/Golang，天津大学毕业，目前是thoughtwork的高级工程师</a></h3>

<h3><a href="http://blog.nastul.com/t">nastul：中南大学好友，常见搞安卓和web，目前在墨尔本大学研究机器学习</a></h3>

<h3><a href="http://www.zpnaruto.cn/">gay平 ：zpnaruto，腾讯前端，中南大学隔壁宿舍的好基友</a></h3>

</br>

<hr />

</br>

<h1>CSU相关</h1>

<h3><a href="http://www.iseedog.com/">joyseedog：权哥，今日头条iOS</a></h3>

<h3><a href="http://zhangdongxuan.com">zhangdongxuan：微信iOS</a></h3>

<h3><a href="http://tsukasa.moe/">Tsukasa：也是白学家，华为云java</a></h3>

<h3><a href="https://ekyu.moe">Equim：Eq酱，C#、node.js，大神学弟，女装大佬</a></h3>

<h3><a href="http://www.andygu.cn/">AndyGu：豪哥，安卓开发</a></h3>

</br>

<hr />

</br>

<h1>一些组织</h1>

<h3><a href="http://csuapple.com/">中南大学苹果实验室：大三时候作为第一个程序员加入的学校实验室</a></h3>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>76</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 23:42:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-23 15:42:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e4%ba%9b%e9%93%be%e6%8e%a5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2296]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://tokyohot.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.198.234.180]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-30 22:25:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-30 14:25:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[友链最近都被墙了？都打不开。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>19</wp:comment_id>
			<wp:comment_author><![CDATA[bugzhang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[nuptunee@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://bugzhang.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.157.56.179]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-31 22:10:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-31 14:10:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[一部分一直在墙外，一部分是估计不更新了。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>13</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810663.08253;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810755.73754;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551861815.0874541;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628006.5823619;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628293.201447;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					</item>
					<item>
		<title>一个简易留言板</title>
		<link>http://bugzhang.com/?p=333</link>
		<pubDate>Mon, 01 Aug 2011 12:21:47 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=333</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://img.bugzhang.com/banner.jpg" alt="" />
这是一个留言板，输入密码后可以在下边的评论框中留言]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>333</wp:post_id>
		<wp:post_date><![CDATA[2011-08-01 20:21:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2011-08-01 12:21:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e4%b8%aa%e7%ae%80%e6%98%93%e7%95%99%e8%a8%80%e6%9d%bf]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[1004]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[48]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript抽象语法树及其应用</title>
		<link>http://bugzhang.com/?p=46</link>
		<pubDate>Fri, 15 Sep 2017 14:53:11 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=46</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0034.jpg" alt="" />

<h3>抽象语法树</h3>

又叫AST或者语法树，是源代码抽象语法结构的树形式。AST的生成规则主要是通过分析代码中的关键字、操作符、变量等类型以及代码的结构，生成出来，当然会忽视一些括号、分号等内容，这些东西在AST上是找不到的。通过操作AST，可以获取到节点，精准的定位到声明语句、赋值语句、运算语句等等，实现对代码的分析、优化、变更等操作。

<img src="http://while4.com/2017/05/19/AST/1459949808babel.png" alt="" />

抽象语法树作为语言底层原理，与编译器、代码优化、代码转换等有重要关系。

<h3>JavaScript抽象语法树</h3>

JavaScript的语法树生成可以通过这个网站的工具 http://esprima.org/ ，生成一个json文件进行描述。
一些常见的赋值语句与判断语句的AST是下面这样：

<pre><code class="javascript">foo = 'hello world';
/*
+-------------+            
|  assign(=)  |            
+-------------+            
X        X              
X          X             
+-------+    +-----------------+
|  foo  |    |  'hello world'  |
+-------+    +-----------------+
*/
if (foo === true) {
  bar = 'hello world';
  alert(bar);
}
/*
+------+                                   
|  if  |                                   
+------+                                   
X    X                                    
X        X                                  
+--------------+    +-------------+                      
|  equal(===)  |    |  if_body    |                      
+--------------+    +-------------+                      
X        X              X         X                      
X         X                X          X                    
+-------+   +--------+    +-------------+   +------------+        
|  foo  |   |  true  |    |  assign(=)  |   |  alert()   |        
+-------+   +--------+    +-------------+   +------------+        
X        X                  X        
X            X                  X      
                       +-------+   +-----------------+    +-------+
                       |  bar  |   |  'hello world'  |    |  bar  |
                       +-------+   +-----------------+    +-------+
*/
</code></pre>

很多现代前端的工具，其底层原理是JavaScript的AST，比如Webpack、UglifyJS、Lint、Babel、TS、JSX等等都有应用。&lt;br&gt;
ps:最早我以为这类工具是通过正则做到的，原理是正则匹配到相关代码，然后将其转换，后来锋哥聊他用QT写的一个编辑器（https://github.com/rhythm1995/Nider ）的时候，他说道代码高亮最早是用监听空格然后关键字判断这种爆搜的方式做的，性能低下，后来写过类似工具的天哥说道AST，然后最早了解。

<h3>UglifyJS</h3>

UglifyJS是主要的JavaScript压缩与代码混淆工具，其本身就是一个AST分析工具！通过UglifyJS对JavaScript代码的压缩，可以极大的降低文件大小从而提升前端性能。
可以干的事情有：

<ul>
<li>字符串解析成AST</li>
<li>解析AST，计算出作用域、变量名等</li>
<li>提供遍历AST的方法，找到你想要修改的节点</li>
<li>提供把AST打印成源代码的功能</li>
<li>提供美化代码的功能</li>
<li>提供定位某个token位置的功能</li>
</ul>

压缩原理大概是，生成语法树后把不重要的都删掉。
混淆原理稍微复杂，用下边代码解释。

<h5>1、约定规则，符串怎么混？变量名怎么混？函数名怎么混？逻辑操作符变函数？这里约定了规则，变量名a,b,c依次往后，估计就没人读得懂了。如：</h5>

<pre><code class="javascript">混淆前：
var Global = "我是一个全局变量";
function test() { //该方法中没有用过Global
var left = "我是一个局部变量";
var right = "我是一个局部变量";
var temp = "我是一个局部变量";
}
混淆后：
var a = "我是一个全局变量";
function test() { //该方法中没有用过Global
var a = "我是一个局部变量";
var b = "我是一个局部变量";
var b = "我是一个局部变量";
}
</code></pre>

<h5>2、生成AST</h5>

我用第一段提到的工具生成json文件描述，如下：

<pre><code class="json">{
    "type": "Program",
    "body": [
        {
            "type": "VariableDeclaration",
            "declarations": [
                {
                    "type": "VariableDeclarator",
                    "id": {
                        "type": "Identifier",
                        "name": "Global"
                    },
                    "init": {
                        "type": "Literal",
                        "value": "我是一个全局变量",
                        "raw": "\"我是一个全局变量\""
                    }
                }
            ],
            "kind": "var"
        },
        {
            "type": "FunctionDeclaration",
            "id": {
                "type": "Identifier",
                "name": "test"
            },
            "params": [],
            "body": {
                "type": "BlockStatement",
                "body": [
                    {
                        "type": "VariableDeclaration",
                        "declarations": [
                            {
                                "type": "VariableDeclarator",
                                "id": {
                                    "type": "Identifier",
                                    "name": "left"
                                },
                                "init": {
                                    "type": "Literal",
                                    "value": "我是一个局部变量",
                                    "raw": "\"我是一个局部变量\""
                                }
                            }
                        ],
                        "kind": "var"
                    },
                    {
                        "type": "VariableDeclaration",
                        "declarations": [
                            {
                                "type": "VariableDeclarator",
                                "id": {
                                    "type": "Identifier",
                                    "name": "right"
                                },
                                "init": {
                                    "type": "Literal",
                                    "value": "我是一个局部变量",
                                    "raw": "\"我是一个局部变量\""
                                }
                            }
                        ],
                        "kind": "var"
                    },
                    {
                        "type": "VariableDeclaration",
                        "declarations": [
                            {
                                "type": "VariableDeclarator",
                                "id": {
                                    "type": "Identifier",
                                    "name": "temp"
                                },
                                "init": {
                                    "type": "Literal",
                                    "value": "我是一个局部变量",
                                    "raw": "\"我是一个局部变量\""
                                }
                            }
                        ],
                        "kind": "var"
                    }
                ]
            },
            "generator": false,
            "expression": false,
            "async": false
        }
    ],
    "sourceType": "script"
}
</code></pre>

<h5>3、对AST操作</h5>

生成AST后，树种节点与分支就确定了变量、操作符与作用域。这里把同一作用域的name替换即可完成这条规则。

<h3>Babel</h3>

Babel是把ES6转成ES5的工具，蠢萌的我曾经看过babel转换后的代码，当时的理解就是let,const转var；=&gt;转；模板字符串转字符串拼接。。。后来提升了姿势水平，知道了AST这个高大上的东西，才明白babel原理：

<ul>
<li>1.babylon进行解析，得到源代码AST</li>
<li>2.plugin用babel-traverse对AST树进行遍历转译，得到新的AST</li>
<li>3.用babel-generator通过AST树生成ES5代码</li>
</ul>

简直神奇！

ts过程大概和babel类似，不在总数，而webpack因为本身太复杂，之后再学习的时候再总结。
参考文章：http://www.iteye.com/news/30731，http://blog.csdn.net/dear_mr/article/details/72587908]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>46</wp:post_id>
		<wp:post_date><![CDATA[2017-09-15 22:53:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-15 14:53:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91%e5%8f%8a%e5%85%b6%e5%ba%94%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82"><![CDATA[前端底层]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2122]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript垃圾回收机制</title>
		<link>http://bugzhang.com/?p=48</link>
		<pubDate>Mon, 25 Sep 2017 15:06:27 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=48</guid>
		<description></description>
		<content:encoded><![CDATA[kdown>
<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0037.jpg" alt="" />

<h3>操作系统的三种内存分配机制</h3>

<strong>静态分配</strong>：
从静态存储区域分配内存。程序编译的时候内存已经分配好了，并且在程序的整个运行期间都存在，如静态变量和全局变量。

<strong>自动分配</strong>：
在栈中为局部变量分配内存的方法，栈中的内存可以随着代码块退出时的出栈操作被自动释放。例如在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数结束时这些存储单元自动被释放。

<strong>动态分配</strong>：
从静态存储区域分配内存。程序编译的时候内存已经分配好了，并且在程序的整个运行期间都存在，如静态变量和全局变量。

栈在底堆在上，function的执行都是通过入栈出栈，执行的时候去堆取到数据推入执行栈，成员变量在堆，局部变量在栈，全局变量也在堆；引用类型的引用变量存储在栈中，指向于实际存储在堆中的实际对象。

<h3>标记清楚</h3>

JavaScript最常用的垃圾回收方式是标记清楚，标记清楚是最早ie游览器采用的方式，现代游览器基本全部使用标记清楚的垃圾回收策略。
标记清楚：当变量进入执行环境（在函数里声明，赋值等），变量被标记为进入环境，进入环境的变量的内存永远不会释放，当变量离开环境（执行完函数）时，标记为“离开环境”，将其内存回收。

<h3>引用计数</h3>

引用计数在JavaScript内存回收中用的较少，现在只有KDE下的KJS引擎的游览器在采用，而最早是网景3游览器采用了这种方式。
引用计数的含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型赋值给变量时，引用次数是1.如果值又赋给另外一个变量，引用次数加1，如果包含这个值引用的变量取得了其他值，引用次数减1，当引用次数为0，表示不能再访问到，即可回收。
值得注意的是，虽然基本没有游览器上JavaScript使用引用计数了，但ie9一下游览器很多对象不是原生JavaScript对象，比如DOM与BOM中的对象就是c++以COM（组件对象模型）实现的，而COM的垃圾回收采用的是引用计数策略，因此即使游览器采用标记清楚实现垃圾回收，但只要在游览器设计COM对象，就使用了引用计数。这会引起循环引用的问题。如；

<pre><code class="javascript">var ele = document.getElementById('ele');
var myObj = new Object();
myObj.ele = ele;  //新对象一个属性引用了com对象
ele.someObj = myObj;  ///com对象一个属性引用了JavaScript对象
</code></pre>

在上述情况下，即使将DOM从页面移除，其内存也不会被回收。为了避免出现，要在使用完毕后手工回收，赋值<code>null</code>来手工解除引用。
                ie9以上的游览器上，BOM与DOM变成了JavaScript对象，不会再出现这个问题，但做兼容性处理的时候这种内存泄漏是要考虑的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>48</wp:post_id>
		<wp:post_date><![CDATA[2017-09-25 23:06:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-25 15:06:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82"><![CDATA[前端底层]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[882]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>前端安全小结</title>
		<link>http://bugzhang.com/?p=50</link>
		<pubDate>Fri, 22 Sep 2017 15:08:02 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=50</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0035.jpg" alt="" />
读阿里吴翰清大神《白帽子谈Web安全》的总结。

<img src="http://7xqgks.com1.z0.glb.clouddn.com/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8.png" alt="" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>50</wp:post_id>
		<wp:post_date><![CDATA[2017-09-22 23:08:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-22 15:08:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%89%8d%e7%ab%af%e5%ae%89%e5%85%a8%e5%b0%8f%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%ae%89%e5%85%a8"><![CDATA[安全]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[681]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>模板引擎原理及部分实现</title>
		<link>http://bugzhang.com/?p=54</link>
		<pubDate>Thu, 14 Sep 2017 15:10:40 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=54</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0045.jpg" alt="" />

<blockquote>
  模板引擎，是前端MV*架构中view的重要组成部分，是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。多数前端框架都用到了前端模板引擎。
</blockquote>

<h3>前端模板引擎类型</h3>

前端模板引擎主要分三类：

<ul>
<li>string-based模板，基于字符串的parse和compile，如ejs、hbs；</li>
<li>dom-based模板，基于dom的link或compile，如angular、vue的模板；</li>
<li>虚拟dom模板，基于v-dom和ast，如React的模板jsx。</li>
</ul>

<h3>字符串模板引擎</h3>

<h5>1.String-based模板原理</h5>

字符串模板引擎主要依赖一下这几个dom API：<code>createElement，appendChild，innerHTML</code>。
在这些api中，<code>innerHTML</code>有最佳的可读性与实用性，成为事实上的主要标准，虽然其他API可能在性能上更胜一筹，但原生js的字符串生成方案中，最常用的还是<code>innerHTML</code>。
构建过程如下：
<img src="http://ogw2109sg.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.png" alt="" />
1.把整个文档作为字符串输入。
2.通过一个带正则的函数，将模板按照标记分为js表达式、模板语法、正常HTML语法。
3.合并成一个js表达式，这个可以接受数据作为输入。
4.输入数据后，输出字符串。
5.该字符串即可拼接为html代码。

<h5>2.String-based模板实现demo</h5>

大概实现下，约定一个语法，以经典的双大括号<code>{{}}</code>作为模板插值。模板如下：

<pre><code class="html">&lt;div id="app"&gt;&lt;/div&gt;
&lt;script type="text/tpl" id="template"&gt;
    &lt;p&gt;name: {{name}}&lt;/p&gt;
    &lt;p&gt;age: {{age}}&lt;/p&gt;
&lt;/script&gt;
</code></pre>

插入的数据：

<pre><code class="javascript">var info = [
    {
        name: 'bugzhang',
        age: 22
    }, {
        name: 'justzht',
        age: 20
    }, {
        name: 'zp',
        age: 20
    }
];
</code></pre>

最重要的模板解析：

<pre><code class="javascript">//解析模板
function template(tpl, data) {
    //定义解析模式
    var re = /{{(.+?)}}/g,
        cursor = 0
    reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,
        code = 'var r=[];\n';

    // 解析html
    function parsehtml(line) {
        // 单双引号转义，换行符替换为空格,去掉前后的空格
        line = line.replace(/('|")/g, '\\$1').replace(/\n/g, ' ').replace(/(^\s+)|(\s+$)/g, "");
        code += 'r.push("' + line + '");\n';
    }

// 解析js代码       
    function parsejs(line) {
        // 去掉前后的空格
        line = line.replace(/(^\s+)|(\s+$)/g, "");
        code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n';
    }

    while ((match = re.exec(tpl)) !== null) {
        // 开始标签  {{ 前的内容和结束标签 }} 后的内容
        parsehtml(tpl.slice(cursor, match.index))
        // 开始标签  {{ 和 结束标签 }} 之间的内容
        parsejs(match[1])
        // 每一次匹配完成移动指针
        cursor = match.index + match[0].length;
    }
    // 最后一次匹配完的内容
    parsehtml(tpl.substr(cursor, tpl.length - cursor));
    code += 'return r.join("");';
    return new Function(code.replace(/[\r\t\n]/g, '')).apply(data);
}
//把生成的字符串插入app节点
var tpl = document.getElementById("app").innerHTML.toString();
document.getElementById("content").innerHTML = template(tpl, info);
</code></pre>

<h5>3.String-based模板优点与缺点</h5>

优点主要有：

<ul>
<li>快速的初始化时间</li>
<li>同时适用于服务器端与客户端，对SSR有最好的支持度</li>
<li>语法支持好</li>
</ul>

缺点也很明显：

<ul>
<li>存在安全隐患</li>
<li>性能较低下</li>
<li>渲染后与数据断开联系</li>
</ul>

<h3>dom模板引擎</h3>

<h5>1.原理概述</h5>

dom-based模板引擎，输出的直接是dom，很多著名框架的模板都是采用了dom-based模板，如angular.js，vue.js，avalon.js，regular.js。
构建过程如下：
<img src="http://7xqgks.com1.z0.glb.clouddn.com/dom%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.png" alt="" />
1.从字符串中生成不带数据的无状态模板；
2.从无状态模板编译成动态模板；
3.动态模板与model进行绑定，完成插值的功能。

<h5>2.优缺点</h5>

优点主要有：

<ul>
<li>与数据绑定，可以不需要操作dom更改view</li>
<li>运行高效</li>
<li>指令带来的声明式开发</li>
</ul>

缺点：

<ul>
<li>安全问题</li>
<li>信息冗余度高</li>
<li>初次进入dom的内容不是最终想要的内容</li>
</ul>

<h3>V-dom模板</h3>

目前了解不多，而且v-dom内容比较多，以后再单独写这块。

参考：https://segmentfault.com/a/1190000004420078，http://blog.csdn.net/yczz/article/details/49585381]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>54</wp:post_id>
		<wp:post_date><![CDATA[2017-09-14 23:10:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-14 15:10:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%a8%a1%e6%9d%bf%e5%bc%95%e6%93%8e%e5%8e%9f%e7%90%86%e5%8f%8a%e9%83%a8%e5%88%86%e5%ae%9e%e7%8e%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82"><![CDATA[前端底层]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[748]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>网易面试</title>
		<link>http://bugzhang.com/?p=60</link>
		<pubDate>Sat, 23 Sep 2017 15:15:06 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=60</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0042.jpg" alt="" />

<h3>一面（1小时）</h3>

1.自我介绍。
2.问项目，问实习。
3.indexDB，cookie,localStorage,sessionStorage区别。
4.游览器缓存机制。就是HTTP相关字段的解释。
6.js合并后与合并前哪个快，也就是一个<code>&amp;lt;script&amp;gt;</code>标签与两个情况下，哪个更快。第一反应合并后，说合并后减少http请求，后边反应过来说不一定，看script位置，如果在head里优先于css与dom加载了的话，会阻塞影响的，同时还说了游览器引擎渲染过程这些分析了，然后提到了defer异步，被问除了defer还有什么，说了async，被问区别。然后面试官说只考虑理想情况，都是正常些都在Body底部，那个快？我坚持的认为合并后快，但面试官说http是同步多线程的，所以多个请求。
7.HTTP请求报文结构，当年腾讯实习生招聘问我这个没答好，回去看了HTTP权威指南，所以说了一部分后追问真实HTTP是怎么区分各个字段的，我说换行，那冒号呢？这个不懂了。
8.事件绑定的原理，冒泡与捕获概念以及API。
9.手写代码，封装一个事件处理函数。
10.点击input事件传播的全过程，除了focus,blur,click想不起来了。
11.简单定位问题，修改后的定位，思考几秒后没想出来（其实很简单），然后面试官问你是不是CSS不好，我说是的不擅长CSS。
12.CSS画三角形。
13.box-sizing。
14.z-index，追问了何时生效，我说我用的时候position是absolute的，只知道肯定有定位条件具体什么不清楚。后来查了是被定位了的元素才会生效。
15.看过那些前端书籍。听完面试官说你一本css都没看过，怪不得css不好。
16.面试结束，有没有问题问。我问网易智能与感知中心做什么工作，期间聊到了对人工智能，VR、AR的认知。面试官建议学好JS基础同时也适当注重下CSS，找本书看看。

<h3>二面（30分钟）</h3>

1.自我介绍。
2.项目介绍。
3.SEO。第一次遇上问SEO，大概说了一些SEO基础后，聊到SPA的SEO怎么优化，结果自己带了个坑说了SSR，然后被问有没有做过SSR，没做过。
4.前端跨域，从同源机制聊到六种跨域方法基本全了。提了CSRF与XSS没讲细节。
5.又问了一次游览器缓存机制。比第一次说的全了一些。
6.谈谈前端工程化理解，答得挺全的，遗憾忘记提ES6，其实我倒是希望被问ES6的问题，前段时间一直写ES6除了个别不常见api外，ES6很熟悉了。
7.又问了一次box-sizing。
8.看了那些书。
9.啥时候学前端的，怎么学的。
10.解释下原型链，两句话说完我感觉说的有点少，然后重说了一次还是两句话。
11.有没有问题要问。我表示惊讶的说这么快。然后问了部门用技术栈，用的工具，人工智能团队前端的业务。后来面试官还给出建议，说我知道的已经很全面，但表述上存在问题，首先声音太小虽然我听的懂，此外说的太快中间不停顿，无法get重点，建议增加下表述条理性。然后面试官介绍说他们用自己开发的regular框架.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>60</wp:post_id>
		<wp:post_date><![CDATA[2017-09-23 23:15:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-23 15:15:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%bd%91%e6%98%93%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
		<category domain="post_tag" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[599]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Zepto源码分析——Zepto选择器</title>
		<link>http://bugzhang.com/?p=64</link>
		<pubDate>Wed, 13 Sep 2017 06:17:11 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=64</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0050.jpg" alt="" />

<blockquote>
  选择器引擎是框架中实现操作的主要方式，可以快速选取到所需元素，通过我们更加熟知的css选择器，zepto的选择器分两大块，一块在zepto.js中的核心选择器qsa方法，另外是selector.js文件，里边封装有一些扩充选择器的实现。
</blockquote>

<h2>选择器引擎概述</h2>

CSS选择符是一条CSS样式中最左边的部分，选择符分为了五大类：元素、关系、伪类、并联、伪元素。其中只有伪元素选择器不能直接被js所选取到。

一般认为，框架的选择器引擎需要包括以下几个基本方法：

<ul>
<li>contain(a,b):判断a中是否包含b，主要用作优化</li>
<li>visible()与hidden():判断是否可见</li>
<li>selected():选中了元素</li>
<li>sortNode():节点的排序与去重，主要为了使更类似于原生方法的排序</li>
<li>filter():过滤器，对于不支持querySelectorAll的游览器，需要对用户的api进行过滤，这个步骤类似词法分析，可以拆分出有用的选择符，对其使用应该的API</li>
</ul>

不过zepto比较奇葩的一点是，zepto主要面向移动端，移动端游览器坑少，所以zepto就直接拿querySelectorAll来匹配非规定外的元素了，好处自不必说，代码少实现简单。坏处就是兼容性不好，也学不到真正选择器引擎的核心，但zepto的优化做的还是很好，也是值得看。而且querySelectorAll这也是未来的趋势。

<h2>Zepto核心选择器</h2>

首先是选择器的实现：

<pre><code class="javascript">zepto.qsa = function (element, selector) {
    var found,
    maybeID = selector[0] == '#',
    maybeClass = !maybeID &amp;&amp; selector[0] == '.',
    nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked
    isSimple = simpleSelectorRE.test(nameOnly)
  return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById
    ((found = element.getElementById(nameOnly)) ? [found] : []) :
    (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] :
    slice.call(
      isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
      maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
      element.getElementsByTagName(selector) : // Or a tag
      element.querySelectorAll(selector) // Or it's not simple, and we need to query all
    )
}
</code></pre>

判断了选择器类型，是id、class、标签还是复杂选择器，然后分别调用getElementById()、getElementsByClassName()、getElementsByTagName()、querySelectorAll()。

其次是否匹配选择器：

<pre><code class="javascript">zepto.matches = function (element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false
    var matchesSelector = element.matches || element.webkitMatchesSelector ||
      element.mozMatchesSelector || element.oMatchesSelector ||
      element.matchesSelector
    if (matchesSelector) return matchesSelector.call(element, selector)
    // fall back to performing a selector:
    var match, parent = element.parentNode,
      temp = !parent
    if (temp)(parent = tempParent).appendChild(element)
    match = ~zepto.qsa(parent, selector).indexOf(element)
    temp &amp;amp;&amp;amp; tempParent.removeChild(element)
    return match
  }
</code></pre>

主要是用来判断当前DOM节点否能完全匹配对应的CSS选择器规则。这个matches方法可以在事件委托等地方被用得上，用来判定匹配到当前标签的元素，当匹配到后添加事件。但原生的兼容性很差，因此框架在这里做了兼容性处理。

<h2>Zepto拓展选择器</h2>

把全部文件站过来，将源码解读写到注释中

<pre><code class="javascript">(function ($) {
    var zepto = $.zepto,
        oldQsa = zepto.qsa,
        oldMatches = zepto.matches
    function visible(elem) {
        elem = $(elem)
        return !!(elem.width() || elem.height()) &amp;amp;&amp;amp; elem.css(&amp;quot;display&amp;quot;) !== &amp;quot;none&amp;quot;
    }
    //这是一套过滤器系统
    var filters = $.expr[':'] = {
        visible: function () {
            if (visible(this))
                return this
        },
        hidden: function () {
            if (!visible(this))
                return this
        },
        selected: function () {
            if (this.selected)
                return this
        },
        checked: function () {
            if (this.checked)
                return this
        },
        parent: function () {
            return this.parentNode
        },
        first: function (idx) {
            if (idx === 0)
                return this
        },
        last: function (idx, nodes) {
            if (idx === nodes.length - 1)
                return this
        },
        eq: function (idx, _, value) {
            if (idx === value)
                return this
        },
        contains: function (idx, _, text) {
            if ($(this).text().indexOf(text) &amp;gt; -1)
                return this
        },
        has: function (idx, _, sel) {
            if (zepto.qsa(this, sel).length)
                return this
        }
    }

    var filterRe = new RegExp('(.*):(\\w+)(?:\\(([^)]+)\\))?$\\s*'),
        childRe = /^\s*&amp;gt;/,
        classTag = 'Zepto' + (+ new Date())
    //分解选择器为三部分，选择器、选择器的过滤器方法、参数
    function process(sel, fn) {
        // quote the hash in `a[href^=#]` expression
        sel = sel.replace(/=#\]/g, '=&amp;quot;#&amp;quot;]')
        var filter,
            arg,
            match = filterRe.exec(sel)
        if (match &amp;amp;&amp;amp; match[2] in filters) {
            filter = filters[match[2]],
                arg = match[3]
            sel = match[1]
            if (arg) {
                var num = Number(arg)
                if (isNaN(num))
                    arg = arg.replace(/^[&amp;quot;']|[&amp;quot;']$/g, '')
                else
                    arg = num
            }
        }
        return fn(sel, filter, arg)
    }

    zepto.qsa = function (node, selector) {
        return process(selector, function (sel, filter, arg) {
            try {
                var taggedParent
                if (!sel &amp;amp;&amp;amp; filter)
                    sel = '*'
                else if (childRe.test(sel))
                // support &amp;quot;&amp;gt; *&amp;quot; child queries by tagging the parent node with a unique class
                // and prepending that classname onto the selector
                    taggedParent = $(node).addClass(classTag),
                        sel = '.' + classTag + ' ' + sel

                var nodes = oldQsa(node, sel)
            } catch (e) {
                console.error('error performing selector: %o', selector)
                throw e
            } finally {
                if (taggedParent)
                    taggedParent.removeClass(classTag)
            }
            return !filter
                ? nodes
                : zepto.uniq($.map(nodes, function (n, i) {
                    return filter.call(n, i, nodes, arg)
                }))
        })
    }

    zepto.matches = function (node, selector) {
        return process(selector, function (sel, filter, arg) {
            return (!sel || oldMatches(node, sel)) &amp;amp;&amp;amp; (!filter || filter.call(node, null, arg) === node)
        })
    }
})(Zepto)
</code></pre>

从源码看出，虽然zepto主要采用的是getElementById()、getElementsByClassName()、getElementsByTagName()、querySelectorAll()这些内置的api完成，思路是分解-&gt;匹配-&gt;调用原生api-&gt;组装zepto对象。

根据不同的情况，给出了不同的提速方案，getElementById是最优先的，因为该api内部做了缓存而且只返回一个节点；getElementsByClassName()、getElementsByTagName()也是比较快的，返回多个节点并且又缓存；只有无法完成时候才进行querySelectorAll()。此外注意的是，getElementsByClassName()、getElementsByTagName()返回的是一个NodeList对象，而querySelectorAll返回的是一个StaticNodeList对象，前者动态后者静态，前者每次匹配到的都是同是缓存引用，后者返回的是不同的Object对象，数据表明前者的速度要快百分之90%以上，这就是为什么尽量用getElementsByClassName()、getElementsByTagName()的原因。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>64</wp:post_id>
		<wp:post_date><![CDATA[2017-09-13 14:17:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-13 06:17:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zepto%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-zepto%e9%80%89%e6%8b%a9%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="zepto-js"><![CDATA[zepto.js]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><![CDATA[源码分析]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[593]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Zepto源码分析——事件模块</title>
		<link>http://bugzhang.com/?p=66</link>
		<pubDate>Tue, 19 Sep 2017 09:18:34 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=66</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0052.jpg" alt="" />
Zepto的事件模块有些简化，因为Zepto作为一个针对移动端游览器的框架，所以游览器的事件系统本身相对完善，不需要做过多事件机制中最复杂的兼容处理。所以在分析后打算总结下针对PC端框架中兼容处理的。

<h2>游览器事件API</h2>

dom提供了三种层级的事件api：html事件、dom0级事件、dom2级事件（可以绑定多个回调）。整个事件机制主要简历在dom0级与dom2级两个标准上：http://bugzhang.com/2017/08/13/chang-yong-de-javascriptdai-ma-duan-2-dom-shi-jian-ajax-cookie/ ，改博文里第一段代码就是相关的实现，此处不再阐述。

<h5>与dom 0级事件的缺陷</h5>

<ul>
<li>对于DOM3新增事件不支持，如：FocusIn,FocsuOut,MouseRemoved,MouseScrill等，但这些事件用的很少</li>
<li>每次只可以绑定一个回调，重复绑定就会取消掉上次的绑定</li>
<li>在ie下回调没有参数，在其他游览器回调第一个参数是事件对象</li>
<li>只能再冒泡阶段可用</li>
</ul>

<h5>ie事件addachEvent的缺陷</h5>

<ul>
<li>this指向的是window，存在内存泄漏</li>
<li>多钟时间绑定回调后，执行顺序不是按照绑定时的顺序触发</li>
<li>与W3C有一些事件有区别</li>
<li>只支持冒泡阶段</li>
</ul>

<h5>addEventListenner的缺陷</h5>

<ul>
<li>部分游览器与标准的事件定义不一致</li>
<li>第四个参数是ff跨文档监听事件，第五个参数是flash下制定监听函数的引用强弱</li>
<li>事件对象不稳定，各个游览器有区别</li>
<li>input事件不如ie的propertychange事件好用</li>
</ul>

<h2>Zepto的Event模块核心方法</h2>

<h5>add：内部用来添加事件的方法</h5>

<pre><code class="javascript">function add(element, events, fn, data, selector, delegator, capture) {
    //拓展标识属性zid
    var id = zid(element),
        set = (handlers[id] || (handlers[id] = []))
    events
        //匹配空格，获取多个event
        .split(/\s/)
        .forEach(function (event) {
            if (event == 'ready')
                return $(document).ready(fn)
            var handler = parse(event)
            handler.fn = fn
            handler.sel = selector
            // 如果事件是emulate mouseenter, mouseleave
            if (handler.e in hover)
                fn = function (e) {
                    var related = e.relatedTarget
                    if (!related || (related !== this &amp;&amp; !$.contains(this, related)))
                        return handler.fn.apply(this, arguments)
                }
            //事件代理
            handler.del = delegator
            var callback = delegator || fn
            handler.proxy = function (e) {
                e = compatible(e)
                if (e.isImmediatePropagationStopped())
                    return
                e.data = data
                var result = callback.apply(element, e._args == undefined
                    ? [e]
                    : [e].concat(e._args))
                if (result === false)
                    e.preventDefault(),
                        e.stopPropagation()
                return result
            }
            handler.i = set.length
            set.push(handler)
            //如果支持dom2级事件
            if ('addEventListener' in element)
                element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
        })
}
</code></pre>

<h5>remove：内部删除事件的方法</h5>

<pre><code class="javascript">function remove(element, events, fn, selector, capture) {
    var id = zid(element)
    eachEvent(events || '', fn, function(event, fn) {
        findHandlers(element, event, fn, selector).forEach(function(handler) {
            delete handlers[id][handler.i]
            element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
        })
    })
}
</code></pre>

就是调用removeEventListener

<h5>on：添加事件</h5>

on是zepto中最核心的事件方法，源码如下：

<pre><code class="javascript">  $.fn.on = function(event, selector, data, callback, one){
    var autoRemove, delegator, $this = this
    if (event &amp;&amp; !isString(event)) {
      $.each(event, function(type, fn){
        $this.on(type, selector, data, fn, one)
      })
      return $this
    }

    if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false)
      callback = data, data = selector, selector = undefined
    if (callback === undefined || data === false)
      callback = data, data = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(_, element){
      //如果是有one=true，先删掉事件，再执行事件
      if (one) autoRemove = function(e){
        remove(element, e.type, callback)
        return callback.apply(this, arguments)
      }
      //按照选择器找到元素
      if (selector) delegator = function(e){
        var evt, match = $(e.target).closest(selector, element).get(0)
        if (match &amp;&amp; match !== element) {
          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))
        }
      }

      add(element, event, callback, data, selector, delegator || autoRemove)
    })
  }
</code></pre>

参数说明：

<ul>
<li>event:事件类型，可以通过空格的字符串方式添加(&quot;click mousedown&quot;)，或者事件类型为键，函数为值的方式({click:function,mousedown:function})。</li>
<li>selector:可选参数，事件委托的节点选择器</li>
<li>data:事件处理程序中的event.data属性</li>
<li>callback:事件处理程序的回调函数</li>
<li>one:绑定事件后，只触发一次回调</li>
</ul>

使用方式：

<pre><code class="javascript">var elem = $('#content')
// observe all clicks inside #content:
elem.on('click', function(e){ ... })
// observe clicks inside navigation links in #content
elem.on('click', 'nav a', function(e){ ... })
// all clicks inside links in the document
$(document).on('click', 'a', function(e){ ... })
// disable following any navigation link on the page
$(document).on('click', 'nav a', false)
</code></pre>

很多其他api是内部通过调用on方法实现的，如：

<pre><code class="javascript">//基于一组特定的根元素为所有选择器匹配的元素附加一个处理事件，匹配的元素可能现在或将来才创建。
$.fn.delegate = function(selector, event, callback){
  return this.on(event, selector, callback)
}
//添加一个处理事件到元素，当第一次执行事件以后，该事件将自动解除绑定，保证处理函数在每个元素上最多执行一次。
$.fn.one = function(event, selector, data, callback){
  return this.on(event, selector, data, callback, 1)
}
//为一个元素绑定一个处理事件。
$.fn.bind = function(event, data, callback){
  return this.on(event, data, callback)
}
</code></pre>

<h5>off：移除事件</h5>

off模块也是主要的核心模块，主要做移除事件

<pre><code class="javascript">$.fn.off = function(event, selector, callback){
    var $this = this
    if (event &amp;&amp; !isString(event)) {
        $.each(event, function(type, fn){
            $this.off(type, selector, fn)
        })
        return $this
    }

    if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false)
        callback = selector, selector = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(){
        remove(this, event, callback, selector)
    })
}
</code></pre>

一些api是内部通过调用off方法实现的，如：

<pre><code class="javascript">//移除Bind绑定的事件
$.fn.unbind = function (event, callback) {
    return this.off(event, callback)
}
//移除通过delegate 注册的事件。
$.fn.undelegate = function (selector, event, callback) {
    return this.off(event, selector, callback)
}
</code></pre>

<h5>trigge与triggerHandler</h5>

在对象集合的元素上触发指定的事件

<pre><code class="javascript">$.fn.trigger = function (event, args) {
    event = (isString(event) || $.isPlainObject(event))
        ? $.Event(event)
        : compatible(event)
    event._args = args
    return this.each(function () {
        // handle focus(), blur() by calling them directly
        if (event.type in focus &amp;&amp; typeof this[event.type] == "function")
            this[event.type]()
        // items in the collection might not be DOM elements
        else if ('dispatchEvent' in this)
            this.dispatchEvent(event)
        else
            $(this).triggerHandler(event, args)
    })
}
$.fn.triggerHandler = function (event, args) {
    var e,
        result
    this.each(function (i, element) {
        e = createProxy(isString(event)
            ? $.Event(event)
            : event)
        e._args = args
        e.target = element
        $.each(findHandlers(element, event.type || event), function (i, handler) {
            result = handler.proxy(e)
            if (e.isImmediatePropagationStopped())
                return false
        })
    })
    return result
}
</code></pre>

triggle模拟整个冒泡过程，除了自身，还触发祖先节点与window的同类型的回调，在游览器底层上，使用的方法是dispatchEvent，如果是在ie上是fireEvent。

<h5>$.Event：自定义事件</h5>

<pre><code class="javascript">$.Event = function (type, props) {
    if (!isString(type))
        props = type,
            type = props.type
    var event = document.createEvent(specialEvents[type] || 'Events'),
        bubbles = true
    if (props)
        for (var name in props)
            (name == 'bubbles')
                ? (bubbles = !!props[name])
                : (event[name] = props[name])
    event.initEvent(type, bubbles, true)
    return compatible(event)
}
</code></pre>

底层采用的是游览器的createEvent和initEvent方法来模拟事件，从而实现自定义事件的功能。

<h3>一些补充</h3>

1.很多框架对于事件代理不采用捕获而采用冒泡的原因，是考虑兼容性
2.zepto因为自身主要做移动端的原因，所以对于低版本ie浏览器是不考虑的，我在上述中或多或少做了补充
3.zepto的很大一部分事件实际是在touch模块，这块主要是触摸事件，内容也比较多，打算留到下篇再写]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>66</wp:post_id>
		<wp:post_date><![CDATA[2017-09-19 17:18:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-19 09:18:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[zepto%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e4%ba%8b%e4%bb%b6%e6%a8%a1%e5%9d%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="zepto-js"><![CDATA[zepto.js]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<category domain="post_tag" nicename="%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><![CDATA[源码分析]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[583]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>360校招面试</title>
		<link>http://bugzhang.com/?p=68</link>
		<pubDate>Fri, 29 Sep 2017 09:19:28 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=68</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0051.jpg" alt="" />
做完接到电话告诉我笔试通过了，今天早上10点开始面试，最近最难一场面试，一面发挥良好，顺利过；二面中途问题太难太紧张，后期基本思路很乱，主要还是知识储备不够。

<h2>一面（45分钟）</h2>

1.介绍项目
2.svg与canvas的不同，热力图应该用哪个
3.介绍下vue开发时候如何规划项目，讲了讲组建、通信状态管理、路由、通信方式、打包发布。
4.游览器渲染过程。详细讲了渲染引擎和JS引擎。也讲了些编译原理的东西。
5.webpack本地开发怎么解决跨域的
6.webpack的原理，哪里是词法分析还是语法分析，具体什么？
7.loader和plugin区别，分别做什么
8.vue的v-dom原理，为什么高效，和模板引擎什么区别
9.diff算法
10.深拷贝，写代码。各种数据类型哪些在堆栈上？jquery的extend是浅拷贝还是深拷贝。Json的方法实现有什么缺陷
11.原型继承，写代码不能用ES6的class...extend...
12.service worker
13.websocket
14.flex布局实现栅格，实现水平垂直居中

一面问题比较和我口味，都是实现和研究过的，就全部回答出来包括追问，估计面试官也是给了个比较高的评价，当初给通过让我准备二面。刚结束立即就通知二面，然后二面很难很难，直接血崩了。

<h2>二面（1小时）</h2>

1.前端优化
2.get和post区别，get和post性能差距大不大
3.http基于udp还是tcp？tcp和udp什么区别？几次握手几次断开？为什么要这样设计？如果不这样可能会发生什么？
4.resuful的API设计
5.游览器缓存机制
6.跨域，追问正向代理与反向代理，追问websocket跨域
7.vue平级组件通信
8.200万条数据插入vue的data，不添加watcher怎么实现
9.react平级组件通信
10.rudex的设计思想
11.flux架构的单向数据流有哪些部分组成，和vuex不同点
12.jsx怎么被解析？我说AST，我知道肯定要用AST，具体说说过程。那解析jsx用了babel和webpack的什么插件或者loader
13.组件热加载方案
14.你框架掌握的不是很好。问你js基础吧。写一个观察者模式。我写不出来，讲了下概念。写一个单例模式。
15.遍历一个多叉树，我写了个递归被吐槽复杂度高。后边问我用什么数据结构优化，我说数组。然后没能写出来算法。

10分钟后收到电话告诉我未通过二面。1-6答上了，第7题到第13题基本全部不会或者讲的不清楚。感谢把我虐的很惨的二面面试官。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>68</wp:post_id>
		<wp:post_date><![CDATA[2017-09-29 17:19:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-09-29 09:19:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[360%e6%a0%a1%e6%8b%9b%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[957]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[刘珊]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[119@110.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[60.8.235.118]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-12-24 14:33:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-12-24 06:33:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[加油~！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>数据挖掘——协同过滤</title>
		<link>http://bugzhang.com/?p=83</link>
		<pubDate>Sat, 23 Dec 2017 19:07:33 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=83</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0046.jpg" alt="" />

<h2>协同过滤概念</h2>

协同过滤（collabrative filtering）是最基础的数据挖掘推荐算法，起源是亚马逊的“爱你所爱”算法，即：”A和B兴趣类似，那么A喜欢的事物也会被B习惯“的原理来推荐的。网易云音乐也采用了这个算法做了一部分。

为方便下列叙述，定义以下概念：

<ul>
<li>1.已知喜好的用户A、他的兴趣为A.H、他喜好的事物为A.F；</p></li>
<li><p>2.需要给与推荐的用户B、兴趣为B.H、喜好为B.F。</p></li>
</ul>

<h2>协同过滤要点</h2>

<h3>1.寻找相似用户</h3>

<p>如果A.H与B.H相似，可以定义为相似用户。其值可能是一组数据。
对于一维数据，做差即可。
考虑简单的二维情况，假设A.H有两个数据[a1,b1]，B.H有两个数据[a2,b2]。可以通过曼哈顿距离：

<pre><code>|a1-a2|+|b1-b2|
</code></pre>

计算出两者差距进行衡量。或者通过几何距离就行衡量。
如果是复杂的N维情况，其衡量可以一般化为明式距离：
<img src="http://img.my.csdn.net/uploads/201211/20/1353400356_6225.png" alt="" />

可以看出，当P=1，计算的是曼哈顿距离；P=2，计算的是欧氏距离；P=无穷大，计算的是上确界距离。这个公式可以被用来定义相似用户的距离。改公司的python实现算法是：

<pre><code>def moreMHDdis(a,b):
    sum = 0
    for i in range(len(a)):
        sum += abs(a[i]-b[i])
    return sum
</code></pre>

<h3>2.用户评级差异</h3>

如果出现的数据是下列这样。
（定义满分10分，数字为给物品的评分）

<table>
<thead>
<tr>
  <th>Tables</th>
  <th>物品A</th>
  <th>物品B</th>
  <th>物品C</th>
</tr>
</thead>
<tbody>
<tr>
  <td>用户A</td>
  <td>8</td>
  <td>7</td>
  <td>9</td>
</tr>
<tr>
  <td>用户B</td>
  <td>10</td>
  <td>2</td>
  <td>9</td>
</tr>
<tr>
  <td>用户C</td>
  <td>6</td>
  <td>6</td>
  <td>7</td>
</tr>
</tbody>
</table>

可以看到用户A应该是给每项都打分接近的，用户B是给喜欢的很高，不喜欢的很低，用户C则是打分与A类似但评判标准却比较严格给的更加低一些。这种差异性如果不做处理，可能会给推荐系统带来问题。<br>
对差异性的处理可以利用皮尔逊相关系数解决。这个系数的理解不复杂：我们如果把上述表做成折线图，可以他们之间有线性关系，皮尔逊相关系数就是代表<strong>两组数的线性关系程度</strong>的一个系数，它在二维情况下就是余弦。其计算公式是：

<pre><code>A和B的协方差/(A的标准差∗B的标准差)
</code></pre>

用python实现下：

<pre><code>from math import sqrt

def multipl(a,b):
    sumofab=0.0
    for i in range(len(a)):
        temp=a[i]*b[i]
        sumofab+=temp
    return sumofab

def corrcoef(x,y):
    n=len(x)
    sum1=sum(x)
    sum2=sum(y)
    sumofxy=multipl(x,y)
    sumofx2 = sum([pow(i,2) for i in x])
    sumofy2 = sum([pow(j,2) for j in y])
    num=sumofxy-(float(sum1)*float(sum2)/n)
    den=sqrt((sumofx2-float(sum1**2)/n)*(sumofy2-float(sum2**2)/n))
    return num/den
</code></pre>

<h3>稀疏性问题</h3>

协同过滤的稀疏性问题指的是，在一个超大的集合中：比如一百万本书中，A可能只读了一百本，B读了两百本，其中的交集可能绝大部分是空集。处理方案是对于稀疏度不同的数据，采用不同的距离进行计算。

<ul>
<li>如果数据稠密，比如所有属性没有空，那么使用欧氏距离或者曼哈顿距离是合理的。</p></li>
<li><p>如果数据受分数贬值（即不同用户使用不用的评级）影响，使用皮尔逊相关系数。</p></li>
<li><p>如果数据稀疏，使用余弦相似度</p></li>
</ul>

<h2>协同过滤应用</h2>

<p>协同过滤是数据挖掘推荐算法的基础算法之一，在推荐系统中有广泛应用，计划之后补充一些demo。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>83</wp:post_id>
		<wp:post_date><![CDATA[2017-12-24 03:07:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-12-23 19:07:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8d%8f%e5%90%8c%e8%bf%87%e6%bb%a4%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98"><![CDATA[数据挖掘]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98"><![CDATA[数据挖掘]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[927]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>美团校招面试</title>
		<link>http://bugzhang.com/?p=85</link>
		<pubDate>Sun, 15 Oct 2017 12:11:46 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=85</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0050.jpg" alt="" />

<h1>一面</h1>

1.vue组件通信
2.spa应用，v-dom，diff算法，mvvm，组件化开发
3.水平垂直居中
4.margin坍塌
5.事件模型，捕获与冒泡，哪些事件没有冒泡，没有冒泡的原因是什么
6.事件代理，中间一个不需要事件怎么办，代理的元素内部还有元素怎么办
7.input事件传播
8.tcp过程，http过程，两者啥关系
9.http报文组成，讲了大概二十个字段，很多被问的很细，比如cookie设置哪些，生命周期，http-only，又追问xss。connection取值。缓存机制相关的，哪些字段是游览器缓存哪些是代理服务器缓存优先级如何。（当年实习招聘腾讯问我这个问题，我答得很烂葬送了腾讯实习机会，后来把HTTP弄了个熟，看了遍HTTP权威指南）
10.node的Stream和Buffer区别。
11.跨域问题。手写jsonp。说说代理服务器具体那种。
12.原型链，当时没讲太清楚，面试官没理解，后边面试官说，算了，我觉得你应该搞懂原型链是啥，你讲讲{},[],Array,Object这死者啥关系吧
12.原型A，原型B，让C继承A也继承B。
13.咋学习的

<h1>二面</h1>

就三个问题面了一个小时
1.怼了半天项目。具体问了项目里的前端优化，然后我说完方案后问原理，问websocket原理，lasyload组件咋设计，考虑哪些因素，你最后优化了多少，首屏加载时间怎么算出来的。最后你这个内部方法单元测试用例怎么写。这个被怼的很惨。
2.网页上边出现广告的现象见没见过，什么原因。我说不知道，面试官说XSS可以实现不，我说肯定可以的。又问了问xss的东西，后来他说是不是XSS，我说肯定不是，之后引导我思考url全过程，会在哪一步出现问题，就猜想是改DNS，然后说运营商搞的。DNS,UDP,HTTP,HTTPS,IP等一系列网络协议从原理到作用和细节问了个遍。我说是不是DNS劫持，后面试官说你推测是对的，想想怎么解决这个问题，不会。回去你可以查一查。
3.给了个作用域和this的题]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>85</wp:post_id>
		<wp:post_date><![CDATA[2017-10-15 20:11:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-10-15 12:11:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%be%8e%e5%9b%a2%e6%a0%a1%e6%8b%9b%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
		<category domain="post_tag" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[941]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>数据挖掘——内容过滤</title>
		<link>http://bugzhang.com/?p=96</link>
		<pubDate>Tue, 23 Jan 2018 11:10:50 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=96</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0049.jpg" alt="" />
协同过滤是基于社交网络的推荐系统，内容过滤则是依靠物品属性进行推荐的系统。即根据所有用户对物品或者信息的评价，发现物品和物品之间的相似度，然后根据用户的历史偏好信息将类似的物品推荐给该用户。

<h2>归一化</h2>

<h4>概念</h4>

<table>
<thead>
<tr>
  <th>name</th>
  <th align="right">age</th>
  <th align="center">salary</th>
</tr>
</thead>
<tbody>
<tr>
  <td>a</td>
  <td align="right">22</td>
  <td align="center">14000</td>
</tr>
<tr>
  <td>b</td>
  <td align="right">28</td>
  <td align="center">20000</td>
</tr>
<tr>
  <td>c</td>
  <td align="right">25</td>
  <td align="center">16000</td>
</tr>
</tbody>
</table>

在实际的情况中，我们通常会接受到的是上图类似的数据，有很大的取值范围，对此类数据，一般采用的方案是归一化，即将特征数据转换到0到1之间。
比较常用的归一化公式是：
标准分数=（每个值-均值）/标准差

<h4>标准分数的问题</h4>

采用标准分数容易受到极值影响，故在某些时候，可以用中位数代替均值得到绝对标准分数。

<h4>应该采用归一化的情况</h4>

<ul>
<li>所用的数据挖掘方法基于特征的值计算两个对象的距离</li>
<li>不同特征的尺度不同</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>96</wp:post_id>
		<wp:post_date><![CDATA[2018-01-23 19:10:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-23 11:10:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98-%e5%86%85%e5%ae%b9%e8%bf%87%e6%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%8e%a8%e8%8d%90%e7%b3%bb%e7%bb%9f"><![CDATA[推荐系统]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98"><![CDATA[数据挖掘]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98"><![CDATA[数据挖掘]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1154]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://tokyohot.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.198.234.180]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-29 22:49:09]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-29 14:49:09]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你这是明显的偷懒了呀，没有以前的文章用心了。还有期待你来一篇baidu的面经呢！ ;-)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[bugzhang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[nuptunee@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://bugzhang.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.157.56.95]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-30 20:39:22]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-30 12:39:22]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[没有吧，主要是，最近被论文搞的心力憔悴，我都没咋看前端新东西。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810660.477396;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810753.2095599;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551861812.2349889;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628001.155885;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628303.895606;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					</item>
					<item>
		<title>前端日志工具logrocket入门简介</title>
		<link>http://bugzhang.com/?p=103</link>
		<pubDate>Tue, 30 Jan 2018 13:45:25 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=103</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0067.jpg" alt="" />

<h1>工具简介</h1>

LogRocket 是一个前端日志工具，它可以让你像发生在自己的浏览器中那样重现问题。无需猜测错误发生的原因，或者要求用户截图以及日志转储，LogRocket 可以让你重现会话以便快速了解发生了什么错误。无需考虑框架，它适用于任何应用程序，也有插件可以从 Redux、Vuex和@ngrx/tore 上记录额外的上下文。
LogRocket通过从应用程序中捕获日志和会话记录来帮助您修复错误并了解用户的行为。
<img src="https://files.readme.io/b38e152-developer_hero.png" alt="" />

<h1>开始</h1>

1.LogRocket开始非常简单，访问https://app.logrocket.com

获取应用程序ID。

2.通过npm安装LogRocket并且在应用中进行集成。

<pre><code class="javascript">$ npm i --save logrocket

// Code:

import LogRocket from 'logrocket';
LogRocket.init('app/id');
</code></pre>

3.添加相关中间件

可以选择添加三大框架对应的中间件，进一步提高集成度

<a href="https://docs.logrocket.com/docs/redux-middleware">redux</a>

<a href="https://docs.logrocket.com/docs/ngrx-middleware">ngrx</a>

<a href="https://docs.logrocket.com/docs/vuex-plugin">vuex</a>

<h1>原理</h1>

LogRocket是一个JavaScript SDK，通过拦截网站/应用程序中的操作（如网络请求，触摸操作和Redux事件）并将其发送到远程服务器来工作。

您的应用中的每个用户会话都与唯一的LogRocket标识符关联。这些用户会话可以加入到适当的URL，以集成方式提供给开发人员。

<h1>LogRocket能做什么</h1>

前端调试一向比较坑爹，LogRocket就是解决这个问题的。具体包括：

<strong>1.修复错误</strong>
<img src="https://files.readme.io/325de23-Group_13.png" alt="" />
LogRocket向您显示影响用户的最高错误，并为您提供每个错误报告的回放与日志。观看回放与日志有助于您了解用户如何触发错误。

网络请求，JavaScript异常和代码错误都在LogRocket中捕获和重放，可以检查原始HTML / CSS以了解和重现UI错误。

<strong>2.集成后端日志记录工具</strong>
在对后端错误进行分类时，可能不清楚为什么前端提出了意外的请求。LogRocket集成了后端日志记录和错误报告工具，以显示每个后端错误和日志条目的相应前端会话日志。

<strong>3.支持度</strong>
<img src="https://files.readme.io/f891fbf-Group_11.png" alt="" />
通常情况下，用户上报问题时，并不能给出足够的上下文来判断到底发生了什么。

如果你正在使用一个像Intercom的聊天工具，你可以直接将LogRocket整合进去，从而无论用户何时开始聊天，你都可以插入一条记录链接。

<strong>4.依靠流量并发现用户体验问题</strong>
<img src="https://files.readme.io/2b33467-Group_14.png" alt="" />
由于LogRocket记录了一切，因此可以在事实之后智能地发现问题。我们可以根据事件进行搜索和过滤，例如让我们的系统自动检测到用户感到沮丧的时刻——比如愤怒点击了按钮。

LogRocket可以通过一些属性（如用户电子邮件，名称，注册日期，位置，状态，持续时间，页面访问等等）来搜索和过滤会话。如果它发生在应用程序中，可以使用LogRocket搜索来找到它。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>103</wp:post_id>
		<wp:post_date><![CDATA[2018-01-30 21:45:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-30 13:45:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%89%8d%e7%ab%af%e6%97%a5%e5%bf%97%e5%b7%a5%e5%85%b7logrocket%e5%85%a5%e9%97%a8%e7%ae%80%e4%bb%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96"><![CDATA[前端工程化]]></category>
		<category domain="post_tag" nicename="%e8%b0%83%e8%af%95"><![CDATA[调试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[3686]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>11</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://tokyohot.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.198.234.180]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-30 22:14:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-30 14:14:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你这是刚写的？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[bugzhang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[nuptunee@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://bugzhang.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.157.56.95]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-30 22:26:29]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-30 14:26:29]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[之前写一半丢下了现在发出来的，本来想写成教程发现太大收不住尾。而且这东西也没啥难的，用的时候看就行了，所以就写了个简介。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>11</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810662.3229461;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810754.9975629;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551861814.279932;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628005.7372489;s:5:"event";s:11:"recheck-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1565628295.233346;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>20</wp:comment_id>
			<wp:comment_author><![CDATA[kqiu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[kqiu@fiberhome.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[171.82.246.238]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-01 10:35:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-01 02:35:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[可以加下您微信吗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>14</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>迅雷、微众银行面试</title>
		<link>http://bugzhang.com/?p=107</link>
		<pubDate>Sat, 14 Oct 2017 17:27:02 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=107</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0053.jpg" alt="" />

<h3>一面</h3>

1.自我介绍和实习经历

2.闭包作用域

3.vue双向绑定原理

4.api设计

5.读过的书

6.对后端的了解，着重问了node的一些特性

7.http的理解

8.react单向数据流的理解

9.nginx异步非阻塞特性

10.对象的访问器与数据属性

11.前端安全的理解

12.冻结对象、不可拓展对象、密封对象

13.看过那些书，对现代前端怎么看，你认为那种人是很强的前端和很强的工程师

一面还是很基础的，我基本全部答上了，面试官当场就说进入二面了，明天面试。

<h3>二面</h3>

面试官说自己以前是我实习公司深信服的前端，后来知道是隔壁ssl部门的

1.实现一个场景，其中有短视频、允许平移的弹幕、实时聊天，兼容ie9以上。
我提出的解决方案是：css动画完成弹幕；短视频用html5的vedio比如flv.js这种开源方案；实时通信有几种解决方案：websocket、短轮询、长轮询。

里边问的比较深，具体到Http协议和api的使用，自己很多地方没有实现过所以经验不足但这块总体答的还行。弹幕的一个匀速动画问题，被搞的很难受，我真是不擅长写动画。

2.es6的一堆语法：生成器，迭代器，元编程。嗯，都是es6里比较晦涩的部分。

3.for...in...、for()循环、forEach循环的区别，为什么有了前两个还要加forEach。

<h3>微众银行面试</h3>

微众银行很坑爹，全场谈人生一个技术问题都没问。

话说我还是很喜欢腾讯系公司的，结果腾讯捞了我简历没面我，富途证券终面挂，微众银行谈人生挂。可能和鹅系公司无缘啊（更主要原因是我水平确实低）。
。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>107</wp:post_id>
		<wp:post_date><![CDATA[2017-10-15 01:27:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-10-14 17:27:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%bf%85%e9%9b%b7%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="category" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1316]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>数据库范式小结</title>
		<link>http://bugzhang.com/?p=143</link>
		<pubDate>Fri, 16 Feb 2018 10:57:30 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=143</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0059.jpg" alt="" />

<blockquote>
  曾经学过一边数据库原理，但学的程度仅限于考个试，特别是对范式这部分的论述，课本上简直是学术的不能再学术，完全处于背概念和看不懂的坑爹状态。甚至当时对其理解都是觉得这种看上去高大上的东西没必要深究，一心只记得去学crud是sql语句去了，以至于后来接触了sqlserver,mysql,mongodb,redis等好几种数据库了，却对原理一知半解，所以这段时间打算重学一遍数据库原理。今天看了范式相关，自己用自己意思理解总结，好更适合应用一些。
</blockquote>

<h2>范式概念与目标</h2>

简单的说范式就是一种设计数据库时遵循的模式，其主要为了：

1.减少冗余（主要原因）

2.消除异常（次要包括插入异常，更新异常，删除异常）

之后我们以一个老生常谈的电商数据表来分别为其实现三大范式。该数据表如下：

<table>
<thead>
<tr>
  <th>商品编号</th>
  <th align="center">商品名</th>
  <th align="center">数量</th>
  <th align="center">产地</th>
  <th align="center">经销商编号</th>
  <th align="center">经销商名</th>
  <th align="center">经销商地址</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0001</td>
  <td align="center">香蕉</td>
  <td align="center">110</td>
  <td align="center">海南</td>
  <td align="center">003</td>
  <td align="center">A公司</td>
  <td align="center">南京路11号</td>
</tr>
<tr>
  <td>0002</td>
  <td align="center">苹果</td>
  <td align="center">80</td>
  <td align="center">陕西</td>
  <td align="center">006</td>
  <td align="center">B公司</td>
  <td align="center">青年路82号</td>
</tr>
<tr>
  <td>0003</td>
  <td align="center">草莓</td>
  <td align="center">90</td>
  <td align="center">山东</td>
  <td align="center">002</td>
  <td align="center">C公司</td>
  <td align="center">新华路20号</td>
</tr>
<tr>
  <td>0004</td>
  <td align="center">荔枝</td>
  <td align="center">50</td>
  <td align="center">海南</td>
  <td align="center">003</td>
  <td align="center">A公司</td>
  <td align="center">南京路11号</td>
</tr>
</tbody>
</table>

此外需要注意的是，每个上级范式都是层层递进的：即第二范式需要先满足第一范式，第三范式需要先满足第二范式。

<h2>第一范式</h2>

第一范式：字段是最小的的单元不可再分（所谓满足原子性）
如原始表就是一个满足第一范式的数据表：

<blockquote>
  商品表
</blockquote>

<table>
<thead>
<tr>
  <th>商品编号</th>
  <th align="center">商品名</th>
  <th align="center">数量</th>
  <th align="center">产地</th>
  <th align="center">经销商编号</th>
  <th align="center">经销商名</th>
  <th align="center">经销商地址</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0001</td>
  <td align="center">香蕉</td>
  <td align="center">110</td>
  <td align="center">海南</td>
  <td align="center">003</td>
  <td align="center">A公司</td>
  <td align="center">南京路11号</td>
</tr>
<tr>
  <td>0002</td>
  <td align="center">苹果</td>
  <td align="center">80</td>
  <td align="center">陕西</td>
  <td align="center">006</td>
  <td align="center">B公司</td>
  <td align="center">青年路82号</td>
</tr>
<tr>
  <td>0003</td>
  <td align="center">草莓</td>
  <td align="center">90</td>
  <td align="center">山东</td>
  <td align="center">002</td>
  <td align="center">C公司</td>
  <td align="center">新华路20号</td>
</tr>
<tr>
  <td>0004</td>
  <td align="center">荔枝</td>
  <td align="center">50</td>
  <td align="center">海南</td>
  <td align="center">003</td>
  <td align="center">A公司</td>
  <td align="center">南京路11号</td>
</tr>
</tbody>
</table>

<h2>第二范式</h2>

第二范式：表中的字段必须完全依赖于全部主键而非部分主键

对此要求的话，对于上述表：如果以商品编号为主键，如第一列中的0001的A公司和第四列0004的A公司冲突，不满足第二范式，故我们需要对上表进行拆分成这样两个表：

<blockquote>
  商品表
</blockquote>

<table>
<thead>
<tr>
  <th>商品编号</th>
  <th align="center">商品名</th>
  <th align="center">数量</th>
  <th align="center">产地</th>
  <th align="center">经销商编号</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0001</td>
  <td align="center">香蕉</td>
  <td align="center">110</td>
  <td align="center">海南</td>
  <td align="center">003</td>
</tr>
<tr>
  <td>0002</td>
  <td align="center">苹果</td>
  <td align="center">80</td>
  <td align="center">陕西</td>
  <td align="center">006</td>
</tr>
<tr>
  <td>0003</td>
  <td align="center">草莓</td>
  <td align="center">90</td>
  <td align="center">山东</td>
  <td align="center">002</td>
</tr>
<tr>
  <td>0004</td>
  <td align="center">荔枝</td>
  <td align="center">50</td>
  <td align="center">海南</td>
  <td align="center">003</td>
</tr>
</tbody>
</table>

<blockquote>
  经销商表
</blockquote>

<table>
<thead>
<tr>
  <th align="center">经销商编号</th>
  <th align="center">经销商名</th>
  <th align="center">经销商地址</th>
</tr>
</thead>
<tbody>
<tr>
  <td align="center">003</td>
  <td align="center">A公司</td>
  <td align="center">南京路11号</td>
</tr>
<tr>
  <td align="center">006</td>
  <td align="center">B公司</td>
  <td align="center">青年路82号</td>
</tr>
<tr>
  <td align="center">002</td>
  <td align="center">C公司</td>
  <td align="center">新华路20号</td>
</tr>
</tbody>
</table>

<h2>第三范式</h2>

第三范式：每列都和主键直接相关，而不是间接相关。
以下数据库表也满足了第三范式。

<blockquote>
  商品表
</blockquote>

<table>
<thead>
<tr>
  <th>商品编号</th>
  <th align="center">商品名</th>
  <th align="center">数量</th>
  <th align="center">产地</th>
  <th align="center">经销商编号</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0001</td>
  <td align="center">香蕉</td>
  <td align="center">110</td>
  <td align="center">海南</td>
  <td align="center">003</td>
</tr>
<tr>
  <td>0002</td>
  <td align="center">苹果</td>
  <td align="center">80</td>
  <td align="center">陕西</td>
  <td align="center">006</td>
</tr>
<tr>
  <td>0003</td>
  <td align="center">草莓</td>
  <td align="center">90</td>
  <td align="center">山东</td>
  <td align="center">002</td>
</tr>
<tr>
  <td>0004</td>
  <td align="center">荔枝</td>
  <td align="center">50</td>
  <td align="center">海南</td>
  <td align="center">003</td>
</tr>
</tbody>
</table>

<blockquote>
  经销商表
</blockquote>

<table>
<thead>
<tr>
  <th align="center">经销商编号</th>
  <th align="center">经销商名</th>
  <th align="center">经销商地址</th>
</tr>
</thead>
<tbody>
<tr>
  <td align="center">003</td>
  <td align="center">A公司</td>
  <td align="center">南京路11号</td>
</tr>
<tr>
  <td align="center">006</td>
  <td align="center">B公司</td>
  <td align="center">青年路82号</td>
</tr>
<tr>
  <td align="center">002</td>
  <td align="center">C公司</td>
  <td align="center">新华路20号</td>
</tr>
</tbody>
</table>

<h2>BC范式</h2>

BC范式：BC范式是第三范式的一种特殊情况，即每个表中只有一个候选主键。上面商品图中：商品编号和商品名同时可以作为主键；经销商表中：所有字段都不同，故都可以作为主键。所以上面数据库设计不满足BC范式。

<h2>总结</h2>

一般情况下，应用范式越高，则数据库表越多，在数据库表多的情况下，带来的问题主要是查询时要连接多个表增加了查询复杂度。

所以需要在降低查询性能的前提下，适量的应用范式以降低冗余即可。一般情况下第二到第三范式就足够，可以按照查询复杂度与冗余度选择适合的范式设计数据库。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>143</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 18:57:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 10:57:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93%e8%8c%83%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[806]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>CSS选择器详解</title>
		<link>http://bugzhang.com/?p=147</link>
		<pubDate>Sat, 17 Feb 2018 03:15:35 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=147</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0056.jpg" alt="" />

<blockquote>
  本文主要论述选择器的详情，及选择器权重优先权
</blockquote>

<h1>基本选择器</h1>

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">名称</th>
  <th align="center">说明</th>
  <th align="center">示例</th>
</tr>
</thead>
<tbody>
<tr>
  <td>#</td>
  <td align="center">id选择器</td>
  <td align="center">选择属性为该id的元素</td>
  <td align="center">#id{}</td>
</tr>
<tr>
  <td>.</td>
  <td align="center">类选择器</td>
  <td align="center">选择属性为class的所有元素</td>
  <td align="center">.class{}</td>
</tr>
<tr>
  <td>tag</td>
  <td align="center">标签选择器</td>
  <td align="center">选择所有的<code>&lt;tag&gt;</code>元素</td>
  <td align="center">div{}</td>
</tr>
<tr>
  <td>*</td>
  <td align="center">通用选择器</td>
  <td align="center">选择所有元素</td>
  <td align="center">*{}</td>
</tr>
</tbody>
</table>

<h1>属性选择器</h1>

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">名称</th>
  <th align="center">说明</th>
  <th align="center">示例</th>
</tr>
</thead>
<tbody>
<tr>
  <td>[attribute]</td>
  <td align="center">通用属性选择器</td>
  <td align="center">选择带有 target 属性所有元素</td>
  <td align="center">[target]</td>
</tr>
<tr>
  <td>[attribute=value]</td>
  <td align="center">属性值选择器</td>
  <td align="center">选择 target="_blank" 的所有元素</td>
  <td align="center">[target=_blank]</td>
</tr>
<tr>
  <td>[attribute~=value]</td>
  <td align="center">包含属性选择器</td>
  <td align="center">选择 title 属性包含单词 "flower" 的所有元素</td>
  <td align="center">[title~=flower]</td>
</tr>
<tr>
  <td>[attribute &#124;=value]</td>
  <td align="center">开头属性选择器</td>
  <td align="center">选择 lang 属性值以 "en" 开头的所有元素</td>
  <td align="center">[lang|=en]</td>
</tr>
</tbody>
</table>

<h1>关系选择器</h1>

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">名称</th>
  <th align="center">说明</th>
  <th align="center">示例</th>
</tr>
</thead>
<tbody>
<tr>
  <td>s1,s2,s3</td>
  <td align="center">分组选择器</td>
  <td align="center">选择多个选择器的元素</td>
  <td align="center">.class1,class2</td>
</tr>
<tr>
  <td>s1 s2</td>
  <td align="center">后代选择器</td>
  <td align="center">指定选择器的后代元素</td>
  <td align="center">div p</td>
</tr>
<tr>
  <td>s1>s2</td>
  <td align="center">子选择器</td>
  <td align="center">指定选择器的子元素</td>
  <td align="center">div>p</td>
</tr>
<tr>
  <td>s1+s2</td>
  <td align="center">相邻兄弟选择器</td>
  <td align="center">选择相邻且之后的元素</td>
  <td align="center">div+p</td>
</tr>
<tr>
  <td>s1~s2</td>
  <td align="center">兄弟选择器</td>
  <td align="center">选择之后的兄弟元素</td>
  <td align="center">div~p</td>
</tr>
</tbody>
</table>

<h1>伪类选择器</h1>

<h3>结构性伪类选择器</h3>

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">名称</th>
  <th align="center">说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>:root</td>
  <td align="center">根元素选择器</td>
  <td align="center">文档根元素，一般为html</td>
</tr>
<tr>
  <td>:first-child</td>
  <td align="center">子元素选择器</td>
  <td align="center">第一个子元素</td>
</tr>
<tr>
  <td>:last-child</td>
  <td align="center">子元素选择器</td>
  <td align="center">最后一个子元素</td>
</tr>
<tr>
  <td>:only-child</td>
  <td align="center">子元素选择器</td>
  <td align="center">只有一个子元素的</td>
</tr>
<tr>
  <td>:only-of-type</td>
  <td align="center">子元素选择器</td>
  <td align="center">子元素只有一种类型的</td>
</tr>
<tr>
  <td>:nth-child(n)</td>
  <td align="center">子元素选择器</td>
  <td align="center">第n个子元素</td>
</tr>
</tbody>
</table>

<h3>表单元素选择器</h3>

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>:enabled</td>
  <td align="center">input非disabled时</td>
</tr>
<tr>
  <td>:disable</td>
  <td align="center">input标签disabled时</td>
</tr>
<tr>
  <td>:checked</td>
  <td align="center">input标签checked时</td>
</tr>
<tr>
  <td>:default</td>
  <td align="center">选择元素之后插入内容</td>
</tr>
<tr>
  <td>:valid</td>
  <td align="center">选择元素之后插入内容</td>
</tr>
<tr>
  <td>:invalid</td>
  <td align="center">块级首字母</td>
</tr>
<tr>
  <td>:required</td>
  <td align="center">选择元素之前插入内容</td>
</tr>
<tr>
  <td>:optional</td>
  <td align="center">选择元素之后插入内容</td>
</tr>
</tbody>
</table>

enabled和disable对input的大部分type都有效，除了checkbox/radio/range三个外。

valid和invalid，是表单校验时使用，自己手动添加valid和invalid属性无用，必须是inp
ut使用pattern和required校验。

<h3>动态伪类选择器</h3>

这些选择器可以配合CSS做一些简单动画

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>选择器</td>
  <td align="center">说明</td>
</tr>
<tr>
  <td>:link</td>
  <td align="center">未被访问时</td>
</tr>
<tr>
  <td>:visited</td>
  <td align="center">已被访问时</td>
</tr>
<tr>
  <td>:hover</td>
  <td align="center">鼠标以上时</td>
</tr>
<tr>
  <td>:active</td>
  <td align="center">访问中跳转页面时</td>
</tr>
<tr>
  <td>:focus</td>
  <td align="center">获得焦点时</td>
</tr>
</tbody>
</table>

<h1>伪元素选择器</h1>

<table>
<thead>
<tr>
  <th>选择器</th>
  <th align="center">说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>::first-line</td>
  <td align="center">块级首行</td>
</tr>
<tr>
  <td>::first-letter</td>
  <td align="center">块级首字母</td>
</tr>
<tr>
  <td>::before</td>
  <td align="center">选择元素之前插入内容</td>
</tr>
<tr>
  <td>::after</td>
  <td align="center">选择元素之后插入内容</td>
</tr>
<tr>
  <td>::selection</td>
  <td align="center">光标滑动选择内容</td>
</tr>
</tbody>
</table>

<h1>权重值与优先级</h1>

<h3>选择器权重值</h3>

<table>
<thead>
<tr>
  <th>等级</th>
  <th align="center">例子</th>
  <th align="center">权重值</th>
</tr>
</thead>
<tbody>
<tr>
  <td>行内样式</td>
  <td align="center">style</td>
  <td align="center">1000</td>
</tr>
<tr>
  <td>ID</td>
  <td align="center">#nav</td>
  <td align="center">100</td>
</tr>
<tr>
  <td>属性选择器/class/伪类</td>
  <td align="center">:hover</td>
  <td align="center">10</td>
</tr>
<tr>
  <td>元素名/伪元素</td>
  <td align="center">::after</td>
  <td align="center">1</td>
</tr>
</tbody>
</table>

<h3>选择器规则</h3>

1.相同的权重：以后面出现的选择器为最后规则

2.不同的权重，权重值高则生效

3.与元素 挨得近 的规则生效，html 中规则的比 CSS 文件的优先

4.!imprtant拥有最高的权重

5.通配符选择器也有权重，权重被认为是 0

6.在css文件上，最后定义的这条规则会覆盖上面与之冲突的规则，也就是说代码行数越大的可以覆盖行数小的

<h3>权重计算公式</h3>

<img src="http://www.nowamagic.net/librarys/images/201203/2012_03_17_01.jpg" alt="" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>147</wp:post_id>
		<wp:post_date><![CDATA[2018-02-17 11:15:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-17 03:15:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[css%e9%80%89%e6%8b%a9%e5%99%a8%e8%af%a6%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="css"><![CDATA[CSS]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[655]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>javascript中的相等&quot;===&quot;与&quot;==&quot;详解</title>
		<link>http://bugzhang.com/?p=165</link>
		<pubDate>Sun, 25 Feb 2018 05:16:44 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=165</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>全等</h1>

js对全等"==="的实现逻辑是如下的：
<img src="http://img.bugzhang.com/%E5%85%A8%E7%AD%89.png" alt="" />

即：
1. 如果 Type(x) 和 Type(y) 不同，返回 false
2. 如果 Type(x) 为 Undefined，返回 true
3. 如果 Type(x) 为 Null，返回 true
4. 如果 Type(x) 为 Number，则进入下面的判断逻辑
4.1. 如果 x 为 NaN，返回 false<br>
4.2. 如果 y 为 NaN，返回 false<br>
4.3. 如果 x 的数字值和 y 相等，返回 true<br>
4.4. 如果 x 是 +0 且 y 是 -0，返回 true<br>
4.5. 如果 x 是 -0 且 y 是 +0，返回 ture<br>
4.6. 返回 false
5. 如果 Type(x) 为 String，则当且仅当 x 与 y 的字符序列完全相同（长度相等，每个位置上的字符相同）时返回 true，否则返回 false
6. 如果 Type(x) 为 Boolean，则若 x 与 y 同为 true 或同为 false 时返回 true，否则返回 false7. 如果 x 和 y 引用的是同一个对象，返回 true，否则返回 false

<h1>不全等==</h1>

不全等的逻辑更加冗长，如下：
<img src="http://img.bugzhang.com/%E9%9D%9E%E5%85%A8%E7%AD%89.png" alt="" />

<ol>
<li>如果 Type(x) 和 Type(y) 相同，则<br></li>
<li>1.1. 如果 Type(x) 为 Undefined，返回 true<br>1.2. 如果 Type(x) 为 Null，返回 true<br>1.3. 如果 Type(x) 为 Number，则<br>1.3.1. 如果 x 是 NaN，返回 false<br>1.3.2. 如果 y 是 NaN，返回 false<br>1.3.3. 如果 x 的数值与 y 相同，返回 true<br>1.3.4. 如果 x 是 +0 且 y 是 -0，返回 true<br>1.3.5. 如果 x 是 -0 且 y 是 +0，返回 true<br>1.3.6. 返回 false<br>1.4. 如果 Type(x) 为 String，则当且仅当 x 与 y 的字符序列完全相同（长度相等，每个位置上的字符相同）时返回 true，否则返回 false<br>1.5. 如果 Type(x) 为 Boolean，则若 x 与 y 同为 true 或同为 false 时返回 true，否则返回 false<br>1.6. 如果 x 和 y 引用的是同一个对象，返回 true，否则返回 false<br></li>
<li>如果 x 是 null 且 y 是 undefined，返回 true<br></li>
<li>如果 x 是 undefined 且 y 是 null，返回 ture<br></li>
<li>如果 Type(x) 为 Number 且 Type(y) 为 String，以 x == ToNumber(y) 的比较结果作为返回<br></li>
<li>如果 Type(x) 为 String 且 Type(y) 为 Number，以 ToNumber(x) == y 的比较结果作为返回值<br></li>
<li>如果 Type(x) 为 Boolean，以 ToNumber(x) == y 的比较结果作为返回值<br></li>
<li>如果 Type(y) 为 Boolean，以 x == ToNumber(y) 的比较结果作为返回值<br></li>
<li>如果 Type(x) 为 String 或 Number 且 Type(y) 为 Object，以 x == ToPrimitive(y) 的比较结果作为返回值<br></li>
<li>如果 Type(x) 为 Object 且 Type(y) 为 String 或 Number，以 ToPrimitive(x) == y 的比较结果作为返回值<br></li>
<li>返回 false</li>
</ol>

所以实际就是这样的表现：
<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1519546038753&amp;di=433922788363eb439577b9e06a9758d0&amp;imgtype=0&amp;src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F912254%2F201610%2F912254-20161025235619187-741352385.png" alt="" />

<h1>完全等同函数</h1>

无论全等还是非全等，对于NaN，以及+0、-0的处理都是非常失败的，因此可以有一个完全等同函数处理这个问题

<pre><code class="javascript">function identity(val1, val2) {
    if(val1===val2){
        if((val1 === -0 || val2 === +0)&amp;&amp;(val1 === +0 || val2 === -0)){
            return false
        }
        return true;
    }else {
        if(val1 === NaN || val2 === NaN){
            return true
        }
        return false;
    }
}
</code></pre>

此外需要注意的就是，在严格模式下，只允许采用全等，另外在代码中，也更加提倡全等以避免不必要的麻烦。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>165</wp:post_id>
		<wp:post_date><![CDATA[2018-02-25 13:16:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-25 05:16:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e4%b8%ad%e7%9a%84%e7%9b%b8%e7%ad%89%e4%b8%8e%e8%af%a6%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%ba%95%e5%b1%82"><![CDATA[前端底层]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1954]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>23</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/schopenhauerzhang</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.9.186.27]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-25 17:32:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-25 09:32:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[完全等同函数的最后一个判断没必要吧？
 if(val1 === NaN || val2 === NaN){
            return true
        }
这个判断是不可能等到TRUE的。
根据上面的那个白色和绿色的表格图（希望你知道我说的哪个图 :lol: ，不过说实话这个图我超喜欢的，以后我写文章也要用这样的图，你怎么画出来的？） :smile: 当其中一个参数是NaN后，就不可能是true全是false（全是白色没有绿色），所以最后一个判断是不可能得到true的。
ps： 为了验证，我console了半天，最后发现有一个白色和绿色的图，无语 :cry:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/schopenhauerzhang</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.9.186.27]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-25 18:03:49]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-25 10:03:49]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[怎么做的，教教我，老司机！！ :razz:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>25</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/schopenhauerzhang</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.9.186.27]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-25 18:05:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-25 10:05:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我记得js中NaN是一种类型参考null，不是具体的值，类型不能等（比如int类型不等于int类型，因为类型还要有对应的值才能相等）
ps：我是从这个角度理解的。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[张明智]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/schopenhauerzhang</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.9.186.27]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-25 18:11:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-25 10:11:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[白色和绿色的那个表格图确实猛。一图顶万言]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>28</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>HTTP认证机制</title>
		<link>http://bugzhang.com/?p=168</link>
		<pubDate>Sun, 10 Dec 2017 05:42:45 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=168</guid>
		<description></description>
		<content:encoded><![CDATA[<img src="http://7xqgks.com1.z0.glb.clouddn.com/head-0068.jpg" alt="" />

<h1>简介HTTP认证</h1>

如果对某个页面有一定要求，只允许部分用户可见，就需要一个认证功能。
认证主要可以通过核对以下信息实现：

<ul>
<li>口令：只有本人知道的一串字符串信息</li>
<li>令牌：仅本人设备产生的一次性密码</li>
<li>证书：仅本人持有的一个信息</li>
</ul>

通过验证核对上述信息，就可以实现认证，对HTTP协议来说，认证主要有以下几种实现：

<ul>
<li>basic认证</li>
<li>digsic认证</li>
<li>ssl客户端认证</li>
<li>基于表单的认证</li>
</ul>

下面分别论述这几种认证方式。

<h1>BASIC认证</h1>

basic认证主要利用的是http中的Authorization字段。主要步骤是：

<ol>
<li>当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW- Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串 (realm)。</li>
<li>接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字 符串内容是由用户 ID 和密码构成，两者中间以冒号(:)连接后，再经过 Base64 编码处理。
假设用户 ID 为 guest，密码是 guest，连接起来就会形成 guest:guest 这样的字符串。然后经过 Base64 编 码，最后的结果即是 Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后，发送请求。
当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的转换 工作。</li>
<li>接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过， 则返回一条包含 Request-URI 资源的响应。</li>
</ol>

BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之， 由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人 窃听，被盗的可能性极高。
另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。 BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。

<h1>DIGEST认证(又叫摘要认证)</h1>

为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的
方式，但不会像 BASIC 认证那样直接发送明文密码。

<ol>
<li>请求需认证的资源时，服务器会随着状态码 401 Authorization Required，返 回带 WWW-
Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码(随机数，nonce)</p></li>
<li><p>接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。</p></li>
<li><p>接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包 含 Request-URI 资源的响应。</p></li>
</ol>

<p>DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认
证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。
DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追 求标准。因此它的适用范围也有所受限。

<h1>SSL客户端认证</h1>

SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

<ol>
<li>接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证
书。</li>
<li>用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给 服务器。</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通
信。</li>
</ol>

<h1>基于表单认证</h1>

基于表单的认证，是利用表单控件中的数据，进行认证。比较有意思的是，基于表单的认证是http协议中未被规范的一种认证方式，但因其方便与良好的用户体验，成为了绝大多数web应用采用的认证方式。
表单认证可以借助cookie，以及加密实现一定的安全机制。

<ol>
<li>客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务
器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
<li>服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，
然后把用户的认证状态与 Session ID 绑定后记录在服务器端。</li>
<li>客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发 送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>168</wp:post_id>
		<wp:post_date><![CDATA[2017-12-10 13:42:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-12-10 05:42:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[http%e8%ae%a4%e8%af%81%e6%9c%ba%e5%88%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="http"><![CDATA[HTTP]]></category>
		<category domain="post_tag" nicename="http"><![CDATA[HTTP]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
		<category domain="post_tag" nicename="%e5%ae%89%e5%85%a8"><![CDATA[安全]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[660]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>搜狐大数据中心前端面试</title>
		<link>http://bugzhang.com/?p=173</link>
		<pubDate>Wed, 21 Mar 2018 12:03:35 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=173</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>一面（60分钟）</h1>

1.vdom原理，为什么性能好， diff算法。最后也要用dom的api，直接操作不效果更好为什么还要用v-dom

2.游览器渲染过程，重绘和回流是什么，发生在何时，那些情况引起，如何优化

3.两栏布局

4.css做一个进度条动画，进度条左右是带弧形的（不会）

5.css菱形，translate的矩阵是怎么算的（没答好）

6.原型链

7.this指向

8.作用域，对const的值修改会输出什么

9.闭包

10.堆栈、js那些在堆那些在栈、垃圾回收。给了个过程与对象分别使用两种垃圾回收机制判定。内存泄漏。能否用编译原理解释闭包与垃圾回收。

11.正则匹配一个邮箱

12.获取页面元素位置与宽高

13.对象继承

<h1>二面（90分钟）</h1>

估计一面面试官出去告诉二面我css不好，于是二面一个css问题都没问我。

1.输出以及为什么

<pre><code>Function.prototype.a = 'a';
Object.prototype.b = 'b';
function Person(){};
var p = new Person();
console.log('p.a: '+ p.a); // p.a: undefined
console.log('p.b: '+ p.b); // p.b: b
</code></pre>

2.输出以及为什么

<pre><code>const person = {
  namea: 'menglinghua',
  say: function (){
    return function (){
      console.log(this.namea);
    };
  }
};
person.say()(); // undefined
const person = {
  namea: 'menglinghua',
  say: function (){
    return () =&gt; {
      console.log(this.namea);
    };
  }
};
person.say()(); // menglinghua
</code></pre>

3.输出以及为什么

<pre><code>setTimeout(() =&gt; console.log('a'), 0);
var p = new Promise((resolve) =&gt; {
  console.log('b');
  resolve();
});
p.then(() =&gt; console.log('c'));
p.then(() =&gt; console.log('d'));
console.log('e');

async function async1() {
    console.log("a");
    await  async2(); 
    console.log("b");

}
async function async2() {
   console.log( 'c');
}
console.log("d");
setTimeout(function () {
    console.log("e");
},0);
async1();
new Promise(function (resolve) {
    console.log("f");
    resolve();
}).then(function () {
    console.log("g");
});
console.log('h');
</code></pre>

js事件循环机制。node与游览器端区别。每个事件发生在何处。（区别没答好，其他ok）

2.写一个构造函数，实现class里的#开头是私有变量（说了匹配与模块模式实现私有变量，没改写get()方法所以被说有问题，经过提醒知道了，算是最大的收获）。

3.用gulp写插件编译这个语法到ES5能不能写出来。（操作AST就行了，应该没问题）

4.实现async（不会，实际是promise语法糖）

6.promise异常处理，实现promise

7.单页应用中游览器url跳转变化了，但没发请求是什么原理，怎么实现的（说了spa路由及原理）

8.http缓存机制，localStorage、sessionStorage。能不能用本地缓存实现类似http缓存机制。indexDB和webSQL。手写连接查询SQL语句。（没问题，能实现）

9.开发者工具中，关于性能的有哪些参数。怎么用。怎么计算首页时间。

10.正则匹配http://www.sohu.com/ 中的主域名（?=即可）

11.反转单链表（写了个递归的)

12.单元测试，敏捷开发与测试驱动开发

13.前端安全的了解：XSS、CSRF、点击劫持、canvas破解验证码，前端sql注入

14.PWA了解多少

15.react生命周期。你不会？会什么。vue，那vue生命周期吧。

<h1>三面（20分钟）</h1>

1.linux文件系统（不会，一出来记起来就是ext2,ext3,fat32那些东西）

2.FIFO、LFU、LRU缓存换页算法

3.进程线程，线程通信

4.画出OSI七层，TCP/IP四层

5.TCP和UDP区别，三次握手四次断开，为什么握手三次，断开四次；TCP的可靠性如何实现；TCP重传机制怎么实现，TCP拥塞控制有哪些；能不能用udp实现tcp

6.CSMA/CA协议（不会）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>173</wp:post_id>
		<wp:post_date><![CDATA[2018-03-21 20:03:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-21 12:03:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%90%9c%e7%8b%90%e5%a4%a7%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%bf%83%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="category" nicename="%e9%9d%a2%e8%af%95"><![CDATA[面试]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2355]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>101</wp:comment_id>
			<wp:comment_author><![CDATA[schopenhauerzhang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[schopenhauerzhang@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[182.204.163.235]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-27 10:22:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-27 02:22:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[👍厉害为了爱情！！！这波狗粮我吃了 :oops:  :lol: 腾讯？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>93</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>529</wp:comment_id>
			<wp:comment_author><![CDATA[虾哔哔]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[mrcxt@foxmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[218.241.202.98]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-07-03 15:53:09]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-07-03 07:53:09]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[楼主这是实习还是社招啊，现在这前端面试都这么难了吗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>662</wp:comment_id>
			<wp:comment_author><![CDATA[bugzhang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[nuptunee@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://bugzhang.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.118.186.23]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-06 02:33:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-05 18:33:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[校招，最后挂了总监面。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>529</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1551810807.1890271;s:5:"event";s:9:"check-ham";s:4:"user";s:8:"bugzhang";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					</item>
					<item>
		<title>javascript中OLOO风格（对象委托）编程</title>
		<link>http://bugzhang.com/?p=191</link>
		<pubDate>Tue, 24 Apr 2018 07:11:51 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=191</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是OLOO</h1>

在《you don't know js》中，作者有提到"OLOO"(objects-linked-to-other-objects)编程风格更适合js，而非传统的面向对象风格。原因是：js本身不提供类，所以是对类的一种模拟，实际实现非常繁琐（从es5的多种继承写法可知），是一种舍本求末的行为，而OLOO风格在该书中被认为是最适合JS的风格。

这是一个Student-Person的OLOO风格例子：

<pre><code class="javascript">var Person = {
  init: function(name) {
    this.name = name;
  },
  getName: function() {
    return this.name;
  }
};

var Student = Object.create(Person);

Student.set = function(name, school) {
  this.init(name);
  this.school = school;
};

Student.getSchool = function() {
  return this.school;
};

var bugzhang = Object.create(Student);
bugzhang.set('Bugzhang', 'CSU');

bugzhang.getName(); // Bugzhang
bugzhang.getSchool(); // CSU
</code></pre>

<h1>OLOO与OOP的对比</h1>

在绝大多数编程语言中，面向对象的实现有两个范式：基于类的面向对象与基于原型的面向对象，前者如c++，java，后者如javacript。

在js中，如果利用构造函数实现继承，那么构造函数不会在原型链上，原型链只有prototype。如果利用prototype实现，其实prototype式继承不好用。

OLOO没有解决property为引用类型时会共享的问题。

在OOP中：采用的是<strong>类-继承</strong>的思想实现。
在OLOO中：采用的是<strong>行为代理模式</strong>的设计思想。OLOO只代表对象利用原型链连接到其他对象。不再使用构造函数来创建对象，而是使用Object.create()为主的方法，利用对象创建对象。

<h1>ES6时代的选择</h1>

在es6中，class关键字的出现，让js模拟类成为了历史。虽然class本质上任然是构造函数原型混合继承的语法糖，但本身简单好用，简化了重复并且没有意义的模板代码，比如<code>xxx.prototype.xxx</code>等；把 class 的 <code>constructor</code> 和普通函数严格区分，避免了 new 的暗坑；加上统一的 <code>super</code> 关键字作为继承的关键字，而且继承链是成线性的。种种有点表明，class应该作为未来主流的方式。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>191</wp:post_id>
		<wp:post_date><![CDATA[2018-04-24 15:11:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-24 07:11:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e4%b8%adoloo%e9%a3%8e%e6%a0%bc%ef%bc%88%e5%af%b9%e8%b1%a1%e5%a7%94%e6%89%98%ef%bc%89%e7%bc%96%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1511]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>golang包管理工具dep</title>
		<link>http://bugzhang.com/?p=195</link>
		<pubDate>Fri, 27 Apr 2018 12:40:37 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=195</guid>
		<description></description>
		<content:encoded><![CDATA[初学golang一段时间后，终于进入能用golang写demo项目的阶段，结果发现原始一直没有学golang包管理工具，对于用习惯npm的开发者，也知道基本现代语言都有包管理工具，于是找了一圈，果然找到很多管理工具，其中就包括官方推荐的dep。

<h1>安装</h1>

安装dep

<pre><code>$ go get -u github.com/golang/dep/cmd/dep
</code></pre>

mac用户也可以采用brew安装

<pre><code>$ brew install dep
</code></pre>

验证安装

<pre><code>$ dep
dep is a tool for managing dependencies for Go projects

Usage: dep &lt;command&gt;

Commands:

  init    Initialize a new project with manifest and lock files
  status  Report the status of the project's dependencies
  ensure  Ensure a dependency is safely vendored in the project
  prune   Prune the vendor tree of unused packages

Examples:
  dep init                               set up a new project
  dep ensure                             install the project's dependencies
  dep ensure -update                     update the locked versions of all dependencies
  dep ensure -add github.com/pkg/errors  add a dependency to the project

Use "dep help [command]" for more information about a command.
</code></pre>

<h1>dep工作流</h1>

<h3>设置环境变量</h3>

一旦安装dep后，我们需要为项目选择根目录，dep要求路径必须在$GOPATH/src，如果还没有设置$GOPATH，可以按照下边方式设置。

<pre><code>#设置环境变量
vi /etc/profile
export GOROOT=/usr/local/go  #设置为go安装的路径
export GOPATH=$HOME/go   #默认安装包的路径
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
source /etc/profile
</code></pre>

GOPATH允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候Windows是分号;，Linux系统是冒号: 
当有多个GOPATH时默认将go get获取的包存放在第一个目录下 
$GOPATH目录约定有三个子目录

src存放源代码(比如：.go .c .h .s等)
pkg编译时生成的中间文件（比如：.a）
bin编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中，如果有多个gopath，那么使用${GOPATH//://bin:}/bin添加所有的bin目录）

<h3>准备一个demo程序</h3>

可以随便创建一个项目，用多个包，创建的项目如下：

<pre><code>//main.go
package main

import (
    "net/http"
    "go.uber.org/zap"
    "github.com/beego/mux"
)

func main() {
    logger, _ := zap.NewProduction()
    defer logger.Sync()
    sugar := logger.Sugar()

    mx := mux.New()
    mx.Handler("GET", "/", http.FileServer(http.Dir(".")))
    sugar.Fatal(http.ListenAndServe("127.0.0.1:9090", mx))
}
</code></pre>

<h3>初始化</h3>

设置好环境变量后，我们开始初始化

<pre><code>$ cd $GOPATH/src &amp;&amp; mkdir myapp
$ dep init
$ ls -ll
-rw-r--r--  1 bugzhang  staff  286  4 27 14:49 Gopkg.lock
-rw-r--r--  1 bugzhang  staff  666  4 27 14:49 Gopkg.toml
drwxr-xr-x  2 bugzhang  staff   64  4 27 14:49 vendor
</code></pre>

可以看到，dep init后生成了三个文件，这三者的关系如下：

<img src="https://gss0.baidu.com/9rkZbzqaKgQUohGko9WTAnF6hhy/mms-res/voice/choujiang/28968009-f49a4a6a-78eb-11e7-93cf-e695d45488da.14d8c0f3.png" alt="" />

<h3>构建</h3>

现在我们的depdemo已经加入了Gopkg.toml和Gopkg.lock。这时，如果你将depdemo clone到你的本地，你还无法进行reproduceable build，因为这时vendor还不存在。这时我们需要执行下面命令来根据Gopkg.toml和Gopkg.lock中的数据构建vendor目录和同步里面的包：

<pre><code>$ dep ensure

$ ls -F
Gopkg.lock  Gopkg.toml  main.go  vendor/
</code></pre>

ensure成功后，就可以进行reproduceable build了。

<h1>补充说明</h1>

<h3>Gopkg.toml</h3>

该Gopkg.toml文件最初由生成dep init，并且主要是手动编辑的。它包含几种管理dep行为的规则声明：

<ul>
<li>依赖关系规则： constraints并overrides允许用户指定哪些版本的依赖关系可接受，以及应从哪些版本检索。</li>
<li>包图规则： required并ignored允许用户分别通过包含或排除导入路径来操作导入图。</li>
<li>metadata是dep将忽略的键值对的用户定义的映射。他们为建立在dep之上的工具提供数据支架。</li>
<li>prune设置决定哪些文件和目录可以被认为是不必要的，从而自动从中删除vendor/。</li>
</ul>

<h3>Gopkg.lock</h3>

该Gopkg.lock文件由dep ensure和生成dep init。它是求解函数的输出：一个项目依赖关系图的过渡完整快照，表示为一系列[[project]]节。这意味着：

<ul>
<li>项目需要编译的每个软件包</li>
<li>加上任何required包裹</li>
<li>减去任何ignored包裹</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>195</wp:post_id>
		<wp:post_date><![CDATA[2018-04-27 20:40:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-27 12:40:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[golang%e5%8c%85%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7dep]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="golang"><![CDATA[golang]]></category>
		<category domain="post_tag" nicename="golang"><![CDATA[golang]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1887]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>使用javascript描述数据结构——栈和队列</title>
		<link>http://bugzhang.com/?p=206</link>
		<pubDate>Thu, 28 Jun 2018 14:35:46 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=206</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>栈</h2>

栈是一种先入后出的数据结构：从末尾添加、从末尾删除，末尾的元素成为栈顶，最先进入的元素称为栈底。
js的数组可以用来模拟数据结构中的栈。

<pre><code>class Stack {

    constructor() {
        this.items = [];
    }

    // 入栈：推入一个元素
    push(element) {
         this.items.push(element);
    }

    // 出栈：移除顶部元素
    pop() {
        return this.items.pop();
    }

    // 获取栈底元素
    get peek() {
        return this.items[this.items.length - 1];
    }

    // 是否为空栈
    get isEmpty() {
        return !this.items.length;
    }

    // 获取长度
    get size() {
        return this.items.length;
    }

    // 清空栈
    clear() {
        this.items = [];
    }

    // 打印栈数据
    print() {
        console.log(this.items.toString());
    }
}
</code></pre>

<h2>队列</h2>

队列是一种遵循先进先出的数据机构；队列在尾部添加新元素，从头部移除元素。最新添加的元素必须排在队列的末尾。

<pre><code>class Queue {

    constructor(items) {
        this.items = items || [];
    }

        // 添加元素
    enqueue(element){
        this.items.push(element);
    }

        // 删除元素
    dequeue(){
        return this.items.shift();
    }

        // 返回第一个元素
    front(){
        return this.items[0];
    }

        // 清空队列
    clear(){
        this.items = [];
    }

        // 队列大小
    get size(){
        return this.items.length;
    }

        // 是否为空
    get isEmpty(){
        return !this.items.length;
    }

        // 打印
    print() {
        console.log(this.items.toString());
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>206</wp:post_id>
		<wp:post_date><![CDATA[2018-06-28 22:35:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-06-28 14:35:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8javascript%e6%8f%8f%e8%bf%b0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[575]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>前端代码风格指南——vue篇</title>
		<link>http://bugzhang.com/?p=214</link>
		<pubDate>Thu, 08 Nov 2018 17:29:45 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=214</guid>
		<description></description>
		<content:encoded><![CDATA[是我常用的一套开发标准，借鉴、删减、自创的一些规则，保留的基本都是比较实用的。用于统一代码风格。并给出了每条标准的理由。

<hr />

<ul>
<li>组件名为多个单词（必须）
> 理由：这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>
</ul>

<pre><code class="js">/* 不推荐的 */
Vue.component('todo', {
  // ...
})
export default {
  name: 'Todo',
  // ...
}

/* 推荐的 */
Vue.component('todo-item', {
  // ...
})
export default {
  name: 'TodoItem',
  // ...
}
</code></pre>

<ul>
<li>prop 的定义应该尽量详细，至少需要指定其类型（必须）
> 理由：一目了然的知道prop是什么，并且在类型报错时可以顺利定位。</li>
</ul>

<pre><code class="js">/* 不推荐的，可以在demo和原型中使用 */
props: ['status']

/* 推荐的 */
props: {
  status: String
}

/* 最好的 */
props: {
  status: {
    type: String,
    required: true,
    validator(value) {
      return [
        'syncing',
        'synced',
        'version-conflict',
        'error'
      ].indexOf(value) !== -1
    }
  }
}
</code></pre>

<ul>
<li>为v-for设置index与key
> 理由：方便维护内部组件及其子树的状态</li>
</ul>

<pre><code class="html">/* 不推荐的 */
&lt;ul&gt;
  &lt;li v-for="todo in todos"&gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;

/* 推荐的 */
&lt;ul&gt;
  &lt;li
    v-for="todo in todos"
    :key="todo.id"
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<ul>
<li>组件命名（可选）

<ul>
<li>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)
> 理由：单词大写开头对于代码编辑器的自动补全最为友好，而对于模板横线连接可以避免大小写不敏感的问题。</li>
</ul>

<pre><code class="html">/* 不推荐的 */
&lt;ul&gt;
&lt;li v-for="todo in todos"&gt;
  {{ todo.text }}
&lt;/li&gt;
&lt;/ul&gt;

/* 推荐的 */
&lt;ul&gt;
&lt;li
  v-for="todo in todos"
  :key="todo.id"
&gt;
  {{ todo.text }}
&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<ul>
<li>只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性
> 理由：增加项目可读性。</li>
</ul>

<pre><code class="js">/* 不推荐的 */
components/
|- Heading.vue
|- MySidebar.vue

/* 推荐的 */
components/
|- TheHeading.vue
|- TheSidebar.vue
</code></pre>

<ul>
<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名
> 理由：增加项目可读性与层级性。</li>
</ul>

<pre><code class="js">/* 不推荐的 */
components/
|- TodoList.vue
|- TodoItem.vue
|- TodoButton.vue

/* 推荐的 */
components/
|- TodoList.vue
|- TodoListItem.vue
|- TodoListItemButton.vue
</code></pre>

<ul>
<li>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾
> 理由：可以首先知道这个组件大概是什么东西，然后知道细节，此外与自然语法相反的这种描述是为了减少连接词的数量，否则组件名会变得很长</li>
</ul>

<pre><code class="js">/* 不推荐的 */
components/
|- ClearSearchButton.vue
|- ExcludeFromSearchInput.vue
|- LaunchOnStartupCheckbox.vue
|- RunSearchButton.vue
|- SearchInput.vue
|- TermsCheckbox.vue

/* 推荐的 */
components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingsCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue
</code></pre>

<ul>
<li>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的
> 理由：编辑器可以自动补全组件名，大驼峰保证了视觉的易识别性，但HTML是大小写不敏感，所以要使用横线连接式。</li>
</ul>

<pre><code class="html">/* 不推荐的 */
&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;mycomponent/&gt;
&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;myComponent/&gt;
&lt;!-- 在 DOM 模板中 --&gt;
&lt;MyComponent&gt;&lt;/MyComponent&gt;

/* 推荐的 */
&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;MyComponent/&gt;
&lt;!-- 在 DOM 模板中 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
</code></pre></li>
<li>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case（建议）

<blockquote>
  理由：遵循js和html的命名习惯。
</blockquote></li>
</ul>

<pre><code class="js">/* 不推荐的 */
props: {
  'greeting-text': String
}
&lt;WelcomeMessage greetingText="hi"/&gt;

/* 推荐的 */
props: {
  greetingText: String
}
&lt;WelcomeMessage greeting-text="hi"/&gt;
</code></pre>

<ul>
<li>模板中的属性多于3个时候，分行写属性（推荐）
> 理由：首先太多的话分行不好读，其次这样比较好看；少的话即使在一行读起来问题不大，而且一行可以少点行数</li>
</ul>

<pre><code class="js">/* 不推荐的 */
&lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value"&gt;
&lt;/el-option&gt;

/* 推荐的 */
&lt;el-option
  v-for="item in options"
  :key="item.value"
  :label="item.label"
  :value="item.value"&gt;
&lt;/el-option&gt;

  &lt;el-button plain @click="open"&gt;可自动关闭&lt;/el-button&gt;
</code></pre>

<ul>
<li>指令全部使用缩写 ，用 : 表示 v-bind: 和用 @ 表示 v-on:（推荐）
> 理由：一样的东西能少些为什么要多写。</li>
</ul>

<pre><code class="js">/* 不推荐的 */
  &lt;input
    v-bind:value="newTodoText"
    @focus="onFocus"
  &gt;

/* 推荐的 */
  &lt;input
    :value="newTodoText"
    @focus="onFocus"
  &gt;

/* 最差的 */
  &lt;input
    v-on:input="onInput"
    @focus="onFocus"
  &gt;
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>214</wp:post_id>
		<wp:post_date><![CDATA[2018-11-09 01:29:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-08 17:29:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%89%8d%e7%ab%af%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97-vue%e7%af%87]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[614]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>前端代码风格指南——CSS篇</title>
		<link>http://bugzhang.com/?p=216</link>
		<pubDate>Wed, 07 Nov 2018 07:35:27 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=216</guid>
		<description></description>
		<content:encoded><![CDATA[是我常用的一套开发标准，借鉴、删减、自创的一些规则，保留的基本都是比较实用的。用于统一代码风格。并给出了每条标准的理由。

<hr />

<ul>
<li>空白与格式（可选）

<ul>
<li>大括号与选择器之间留空，冒号后面留空
> 理由：这样比较好看而且多数已有代码是这样。</li>
</ul>

<pre><code class="css">/* 不推荐的 */
.el-pager{
width:$--pagination-number-after-width;
}

/* 推荐的 */
.el-pager {
width: $--pagination-number-after-width;
}
</code></pre>

<ul>
<li>在只有一条样式时允许和选择器写到同一行，但大括号首尾最好留一个空格。
> 理由：写三行太浪费屏幕空间。</li>
</ul>

<pre><code class="css">/* 不推荐的 */
.el-pager {
  width:$--pagination-number-after-width;
}

/* 推荐的 */
.el-pager { width: $--pagination-number-after-width; }
</code></pre>

<ul>
<li>一个选择器中有多个样式声明时每条写一行
> 理由：使报错可以精确到具体的规则上，便于排错。</li>
</ul>

<pre><code class="css">/* 不推荐的 */
.el-pager {width:$--pagination-number-after-width; height: $--pagination-number-after-height; color: $--pagination-number-after-color;}

/* 推荐的 */
.el-pager {
  width: $--pagination-number-after-width;
  height: $--pagination-number-after-height;
  color: $--pagination-number-after-color;
}
</code></pre>

<ul>
<li>多个选择器使用逗号隔开时写在不同的行，大括号不要另起一行
> 理由：修改时不容易漏掉逗号后面的选择器。</li>
</ul>

<pre><code class="css">/* 不推荐的 */
.el-pager, div {
  width:$--pagination-number-after-width;
}

/* 推荐的 */
.el-pager,
div {
  width:$--pagination-number-after-width;
}
</code></pre>

<ul>
<li>每条样式声明后面都加上分号

<blockquote>
  理由：复制起来方便。
</blockquote></li>
<li>所有最外层引号使用双引号

<blockquote>
  理由：与HTML保持一致。
</blockquote></li>
</ul>

<pre><code class="css">/* 不推荐的 */
@import url(//www.google.com/css/maia.css);
html { font-family: 'open sans', arial, sans-serif; }

/* 推荐的 */
@import url("//www.google.com/css/maia.css");
html {
  font-family: "open sans", arial, sans-serif;
}
.selector[type="text"] { }
</code></pre>

<ul>
<li>用逗号分隔的多个样式值写成多行</li>
</ul>

<blockquote>
  理由：便于阅读和编辑。
</blockquote>

<pre><code class="css">/* 不推荐的 */
  .block {
    box-shadow: 0 0 0 rgba(#000, 0.1), 1px 1px 0 rgba(#000, 0.2), 2px 2px 0 rgba(#000, 0.3), 3px 3px 0 rgba(#000, 0.4), 4px 4px 0 rgba(#000, 0.5);
  }

/* 推荐的 */
.block {
  box-shadow: 0 0 0 rgba(#000, 0.1),
            1px 1px 0 rgba(#000, 0.2),
            2px 2px 0 rgba(#000, 0.3),
            3px 3px 0 rgba(#000, 0.4),
            4px 4px 0 rgba(#000, 0.5);
  }
</code></pre></li>
<li>功能限定（可选）

<ul>
<li>避免使用ID选择器，如无必要禁止使用!important

<blockquote>
  理由：权重太高，不易维护。
</blockquote></li>
<li>禁止使用 @import 引入 CSS 文件，但在SCSS等预编译处理器中是允许的</p></li>
</ul>

<blockquote>
  <p>理由：兼容性差，并且会打破资源下载顺序有性能问题
</blockquote></li>
<li>属性顺序（可选）

<ul>
<li>位置属性(position, top, right, z-index, display, float等)</li>
<li>大小(width, height, padding, margin)</li>
<li>文字系列(font, line-height, letter-spacing, color- text-align等)</li>
<li>背景(background, border等)</li>
<li>其他(animation, transition等)
> 理由：顺序从高到低依次和使用频率直接相关。</li>
</ul></li>
<li>变量与属性命名（可选）

<ul>
<li>0 值的单位建议省略，但不强制。

<blockquote>
  理由：css中所有 0 值的单位是没用的。
</blockquote></li>
<li>16进制颜色值中的字母统一为小写。

<blockquote>
  理由：大小写对CSS是一样的，但切换大写麻烦。
</blockquote></li>
<li>类名中的字母一律小写

<blockquote>
  理由：大小写对CSS是一样的，但难道统一大写或者首字母大写？
</blockquote></li>
<li>类名中只是用用字母、数字以及“-”，并且尽量不要使用数字。

<blockquote>
  理由：CSS类名可以用任何字符，但命名还是和js语言变量统一为好。
</blockquote></li>
</ul>

<pre><code class="css">.hello {} /* OK */
.module-title {} /* OK */
.panel-level1 {} /* OK */

.导航栏 /* Fuck */
</code></pre></li>
<li>CSS模块化（可选）

<ul>
<li>基本命名</li>
<li>除非是非常常见的缩写，否则类名使用完整英文单词或者抽调空格的英文词组
> 理由：正常阅读，缩写可能不统一</li>
</ul>

<pre><code class="css">/* 不推荐的 */
.konnichiwa {} /* 非英文单词会导致大家无法正常阅读 */
.modl {} /* 每个人的缩写未必一致，会造成不统一 */
.hello-world {} /* 类名请只使用一个没有分隔[-_]的词 */

/* 推荐的 */
.module {}
.helloworld {}
.nav {}
</code></pre>

<ul>
<li>仅当有层级关系时候使用“-”连接
> 理由：使css与html的层级一致</li>
</ul>

<pre><code class="css">  .form-submit {} /* 推荐 */
  .form-submittingbutton {} /* 不推荐 */
</code></pre>

<ul>
<li>当要对选择器进行样式的修饰时，可以使用多个类而非对已有类进行定语的限制
> 理由：先前规范已经规定了必须层级关系采用“-”，并且修饰符可能与组件名冲突</li>
</ul>

<pre><code class="css">.success-popup. {} /* 不推荐的 */
.successPopup. {} /* 不推荐的 */

.popup.success {} /* 推荐的 */
.popup.error {} /* 推荐的 */
</code></pre></li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>216</wp:post_id>
		<wp:post_date><![CDATA[2018-11-07 15:35:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-07 07:35:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%89%8d%e7%ab%af%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97-css%e7%af%87]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[517]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Egg.js操作日志模块开发一二</title>
		<link>http://bugzhang.com/?p=223</link>
		<pubDate>Sun, 02 Dec 2018 17:40:09 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=223</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>操作日志的意义</h3>

操作日志顾名思义，就是记录所有对系统的操作，使得系统运行者对系统的运行了如指掌。
对于toB端或者内部管理系统而言，操作日志可以朔源，清楚找到问题所在，从而解决并且为以后避免提供经验。
对于toC端而言，操作日志可以了解用户行为，提供数据分析可以让公司与开发者开发出更加符合用户体验具有用户粘性的产品。

<h3>界面展示</h3>

主要展示内容是

用户 | 模块 | 操作类型 | 何种操作 | 操作前内容 | 操作后内容
| :------| ------: | ------: | ------: | ------: | :------: |
admin | 用户管理 | 修改 | 修改bugzhang权限 | 运维管理员 | 超级管理员

<h3>存储设计</h3>

存储比较灵活，数据库与文件存储可以结合使用，我为了提升数据库性能，将部分敏感操作存入数据库，将次要操作存储入文件。

<strong>操作日志表设计</strong>
<table>
<thead>
<tr>
  <th align="left">字段名</th>
  <th align="right">说明描述</th>
  <th align="center">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
  <td align="left">id</td>
  <td align="right">id</td>
  <td align="center">INTEGER primaryKey autoIncrement</td>
</tr>
<tr>
  <td align="left">ip</td>
  <td align="right">ip地址</td>
  <td align="center">VARCHAR(255)</td>
</tr>
<tr>
  <td align="left">userId</td>
  <td align="right">用户id</td>
  <td align="center">INTEGER</td>
</tr>
<tr>
  <td align="left">user</td>
  <td align="right">用户名</td>
  <td align="center">VARCHAR(255)</td>
</tr>
<tr>
  <td align="left">type</td>
  <td align="right">操作类型： 1. 添加 2.修改 3. 删除 4.查询</td>
  <td align="center">INTEGER</td>
</tr>
<tr>
  <td align="left">target</td>
  <td align="right">操作目标，根据页面的menu页区分： 用户管理、公司业务管理、Doc管理、日志系统、PMU在线模型、监控系统、IDC管理、Wiki文档</td>
  <td align="center">VARCHAR(255)</td>
</tr>
<tr>
  <td align="left">before</td>
  <td align="right">操作前内容</td>
  <td align="center">VARCHAR(1024)</td>
</tr>
<tr>
  <td align="left">after</td>
  <td align="right">操作后内容</td>
  <td align="center">VARCHAR(1024)</td>
</tr>
<tr>
  <td align="left">content</td>
  <td align="right">描述</td>
  <td align="center">VARCHAR(255)</td>
</tr>
<tr>
  <td align="left">remarks</td>
  <td align="right">备注信息</td>
  <td align="center">VARCHAR(255)</td>
</tr>
</tbody>
</table>

<strong>文件存储</strong>
前端有页面可以查文件的尾部多少行的页面，类似tail命令。

<h3>实现</h3>

<ul>
<li>获取IP地址
node.js可以轻松获取ip地址。代码如下：</li>
</ul>

<pre><code>function getClientIP(req) {
    return req.headers['x-forwarded-for'] || // 判断是否有反向代理 IP
        req.connection.remoteAddress || // 判断 connection 的远程 IP
        req.socket.remoteAddress || // 判断后端的 socket 的 IP
        req.connection.socket.remoteAddress;
};
</code></pre>

<ul>
<li>添加日志</li>
</ul>

日志具有添加的核心方法，该方法用于

<pre><code>* create ({ type, target, content, after, remarks = '' }) {
  const { ctx } = this
  try {
    // 这里有一些属于定时任务的操作，并没有用户状态，所以需要特殊处理
    yield ctx.model.LogOperation.create({
      userId: ctx.user ? ctx.user.id : 0,
      user: ctx.user ? ctx.user.name : '定时任务',
      ip: getClientIP() ? getClientIP : '未知ip'
      type,
      target,
      after,
      content,
      remarks
    })
  } catch (err) {
    ctx.logger.error(err)
  }
}
</code></pre>

<ul>
<li>展示日志
日志可以被展示在某个页面中，方法非常简单</li>
</ul>

<pre><code>  * getList ({ limit, offset, where }) {
    const result = yield this.ctx.model.LogOperation.findAndCountAll({
      raw: true,
      offset,
      limit,
      attributes: ['id', 'userId', 'user', 'type', 'content', 'target', 'remarks', ['created_at', 'createdAt']],
      order: [['created_at', 'DESC']],
      where
    })
    return result
  }
</code></pre>

<h3>装饰器模式</h3>

日志记录实际是一种装饰器模式。
装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能，就增加功能来说，装饰器模式相比生成子类更为灵活。
关键实现是： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。
在日志系统中：日志类就是抽象角色，不具体实现；操作类被日志类修饰，从而实现了本来没有的日志记录功能。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>223</wp:post_id>
		<wp:post_date><![CDATA[2018-12-03 01:40:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-02 17:40:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%93%8d%e4%bd%9c%e6%97%a5%e5%bf%97%e7%9a%84%e6%84%8f%e4%b9%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="egg-js"><![CDATA[egg.js]]></category>
		<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="post_tag" nicename="node-js"><![CDATA[node.js]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1407]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>koa源码分析</title>
		<link>http://bugzhang.com/?p=228</link>
		<pubDate>Sun, 03 Feb 2019 07:14:48 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=228</guid>
		<description></description>
		<content:encoded><![CDATA[koa源码非常简单，只有四个文件也就是koa的四大对象：

<ul>
    <li>application.js 包含 app 的构造以及启动一个服务器</li>
    <li>context.js app 的 context 对象, 传入中间件的上下文对象</li>
    <li>request.js app 的请求对象，包含请求相关的一些属性</li>
    <li>response.js app 的响应对象，包含响应相关的一些属性</li>
</ul>

<h1>application主要方法</h1>

application中的构造函数：

<pre><code>constructor() {
  super();

  this.proxy = false;
  // 存放中间件的数组
  this.middleware = [];
  // 忽略的子域名数量
  this.subdomainOffset = 2;
  // 设置环境变量
  this.env = process.env.NODE_ENV || 'development';
  // 挂载context，request，response到application
  this.context = Object.create(context);
  this.request = Object.create(request);
  this.response = Object.create(response);
  if (util.inspect.custom) {
    this[util.inspect.custom] = this.inspect;
  }
}
</code></pre>

application除了构造方法外还有几个主要的方法，包括：

applicaton的createContext方法：

<pre><code>  createContext(req, res) {
    const context = Object.create(this.context);
    const request = context.request = Object.create(this.request);
    const response = context.response = Object.create(this.response);
    context.app = request.app = response.app = this;
    context.req = request.req = response.req = req;
    context.res = request.res = response.res = res;
    request.ctx = response.ctx = context;
    request.response = response;
    response.request = request;
    context.originalUrl = request.originalUrl = req.url;
    context.state = {};
    return context;
  }
</code></pre>

创建了一个context上下文对象，这个对象挂载了app，req，res，ctx等多个属性，属性的含义看缩写即可明白。

application中的listen方法

<pre><code>  listen(...args) {
    debug('listen');
    const server = http.createServer(this.callback());
    return server.listen(...args);
  }
</code></pre>

调用了基础网络库http中的createServer和linsten方法，创建一个服务器并且监听端口。

<h1>koa中间件源码原理</h1>

application中的use方法：

<pre><code>use(fn) {
  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');
  if (isGeneratorFunction(fn)) {
    deprecate('Support for generators will be removed in v3. ' +
              'See the documentation for examples of how to convert old middleware ' +
              'https://github.com/koajs/koa/blob/master/docs/migration.md');
    fn = convert(fn);
  }
  debug('use %s', fn._name || fn.name || '-');
  this.middleware.push(fn);
  return this;
}
</code></pre>

因为中间件是一个用于拦截请求的异步函数，所以首先判断中间件类型是否正确，并且在中间件是generator函数的情况下转为异步函数，然后把推入中间件数组并且返回本身。该步骤仅仅作为注册中间件的功能，中间件数组中的中间件将会在http发生时被依次调用。调用的过程如下：

<pre><code>callback() {
  const fn = compose(this.middleware);

  if (!this.listenerCount('error')) this.on('error', this.onerror);

  const handleRequest = (req, res) =&gt; {
    const ctx = this.createContext(req, res);
    return this.handleRequest(ctx, fn);
  };

  return handleRequest;
}
</code></pre>

这边中间件的执行用了一个koa-compose的库，koa-compose也非常精简，只要一个compose方法的高阶函数，洋葱模型在方法内部实现，只有三十多行：

<pre><code>function compose (middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }

  /**
   * @param {Object} context
   * @return {Promise}
   * @api public
   */

  return function (context, next) {
    // last called middleware #
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i &lt;= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
</code></pre>

前几行做类型判断，不再赘述。
主要内容是返回一个函数，这个函数是一个递归的高阶函数。
最关键的一行是return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
这就会在promise resolve的时候执行fn(context, dispatch.bind(null, i + 1))
这个过程可以被理解为

<pre><code>function compose(){
  return Promise.resolve(
    f1(context,function(){
      return Promise.resolve(
        f2(context,function(){
          return Promise.resolve(
            f3(context,function(){
              return Promise.resolve(
                next(context,function(){
                  return Promise.resolve('fn is undefined')
                })
              )
            })
          )
        })
      )
    })
  )
}
</code></pre>

在一个中间件函数中不能调用两次next()，否则会抛出错误。
为什么执行顺序是1,2,3,4,5,ok,5,4,3,2,1呢。是因为 next() 是把主线程暂时交给下个代码块，所有代码块执行完后会依次收回执行权，而收回的顺序就相反了。

<h1>context主要方法</h1>

相比application，剩下三部分都要简单的多。
Koa处理请求的过程：当请求到来的时候，会通过req和res来创建一个context (ctx)，然后执行中间件，然后再返回响应。
context.js是用来代理ctx的功能，把更多的方法和功能挂载上去，提供对request和response的更多操作。其中最主要的方法是delegate方法，除此之外的方法都是辅助方法或者错误捕获。

<pre><code>delegate(proto, 'response')
  .method('attachment')
  // ...
  .getter('writable');

delegate(proto, 'request')
  .method('acceptsLanguages')
  // ...
  .getter('ip');
</code></pre>

这段操作使得，当访问proto的代理属性的时候，实际上是在访问proto.response的对应属性。

#request和response
两者类似，虽然代码比较长，但实际就是对HTTP的header的一个处理而已，每个方法都非常简单，也调用了一些基础的网络库如url，net等等。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>228</wp:post_id>
		<wp:post_date><![CDATA[2019-02-03 15:14:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-03 07:14:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[koa%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="egg-js"><![CDATA[egg.js]]></category>
		<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="post_tag" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[618]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>node.js web应用优化之读写分离</title>
		<link>http://bugzhang.com/?p=243</link>
		<pubDate>Sun, 14 Apr 2019 16:43:17 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=243</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>概述</h1>

先了解读写分离是什么，什么原理，解决了什么问题。
什么是读写分离？

其实就是将数据库分为了主从库，一个主库用于写数据，多个从库完成读数据的操作，主从库之间通过某种机制进行数据的同步，是一种常见的数据库架构，最常用的web应用优化方式之一。
优化原理是：对于常见的web应用，绝大多数是读操作，少数是写操作，数据库的读会是应用的性能瓶颈。故可以用大量机器专门做读操作，少量机器专门做写操作，一来可以可以消除读写锁冲突，二是节约了服务器资源，避免读成为瓶颈的时候，写业务浪费资源。
读写分离解决了数据库的读成为性能瓶颈。

<h1>手动读写分离</h1>

写两套代码write和read，部署write只做写，部署read只做读。
最原始的实现方法。具体实现很简单不再描述。

<ul>
<li>优点：实现简单，不需要多于知识，性能也会很好。</li>
<li>缺点：一旦需要部署的服务一多，部署和维护会非常麻烦。</li>
</ul>

<h1>利用mysql主从架构实现读写分离</h1>

因为项目通常会使用ORM，故我们用最常用的node的orm——sequelize作为实现实例。其他ORM或者原生都是类似思路。
主要原理就是创建两个sequelize实例，一个负责读一个负责写，分别指定读写数据库，并且把读写数据库部署在不同的机器或者集群。
egg.default.config.js配置：

<pre><code>  config.sequelize = {
    dialect: 'mysql',
    port: 3306,
    replication: {
      read: [
      { host: '192.168.0.1', username: 'root', password: 'pass' },
      { host: '192.168.0.2', username: 'root', password: 'pass' }
      ],
      write: { host: '192.168.0.3', username: 'root', password: 'pass' }
    }
  }
</code></pre>

replication中的read实例会处理所有的select操作，而write会处理instert、delete、update语句。

<ul>
<li>优点：实现简单，维护方便，代码友好不需要额外知识。</li>
<li>缺点：暂时没想到，有想到我再补充。</li>
</ul>

<h1>nginx实现读写分离</h1>

nginx基本成为了通用的代理服务器，Nginx的通过配置可以把不用的请求分配到不同的服务器，只要使用了标准的restful或者近似标准的restful（读get写post）。就可以借助nginx实现读写分离
实现原理：WebDAV，一种基于HTTP的通信协议，拓展了HTTP1.1，使应用程序可以读写web server。
nginx.conf配置：

<pre><code>## 读服务器集群
upstream read {
  server 192.168.0.1 weight=2 max_fails=2 fail_timeout=2;
  server 192.168.0.2 weight=2 max_fails=2 fail_timeout=2;
  server 192.168.0.3 weight=2 max_fails=2 fail_timeout=2;
}

## 写服务器集群
upstream write {
  server 192.168.0.4 weight=2 max_fails=2 fail_timeout=2;
  server 192.168.0.5 weight=2 max_fails=2 fail_timeout=2;
  server 192.168.0.6 weight=2 max_fails=2 fail_timeout=2;
}

server {
    location / {
        proxy_pass  http://read;
        if ($request_method = "POST" || $request_method = "DELETE" || $request_method = "PUT" || $request_method = "PATCH"){
            proxy_pass  http://write;
        }
    }
}
</code></pre>

是我最推荐的一种方式，主要原因是nginx作用很多基本成目前的必须。

<ul>
<li>优点：实现不算难，维护方便，性能高效，不需要接触代码内容，鲁棒性好，通用性好（用人话说，一点都不会的项目我也能把它读写分离部署）。</li>
<li>缺点：需要引入nginx，</li>
</ul>

<h1>MySQL-Proxy等中间件解决</h1>

此类中间件很多，除了官方的mysql-proxy，还有Amoeba等。
mysql中间件服务，上游可接入若干个mysql-client，后端可连接若干个mysql-server。
mysql-proxy可以分析与修改请求，通过中间件支持的脚本，可以判断mysql-client的操作分配到不同的mysql-server。

<ul>
<li>优点：基本不需要修改</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>243</wp:post_id>
		<wp:post_date><![CDATA[2019-04-15 00:43:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-14 16:43:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[243]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="post_tag" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
		<category domain="post_tag" nicename="%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><![CDATA[性能优化]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[884]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>ajax全揭秘</title>
		<link>http://bugzhang.com/?p=250</link>
		<pubDate>Sat, 20 Apr 2019 06:28:21 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=250</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>
  项目中一直都使用ajax的封装库，时间久了难免忘记，前不久看到公司笔试题有实现promise的ajax，居然想不出来完整的。所以把ajax复习一遍，并且封装下。文章会花很大篇幅讲对象基础和原理，如果直接库封装看实现的可以看最后两小节。
</blockquote>

<h1>XMLHttpRequest</h1>

XMLHttpRequest是用于与后台交换数据的对象，XMLHttpRequest不仅仅能传递XML而是允许任何类型的数据传输。
所有现代的浏览器都支持 XMLHttpRequest 对象。
XMLHttpRequest是ajax的实现基础。

XMLHttpRequest 继承了 XMLHttpRequestEventTarget，XMLHttpRequestEventTarget继承了EventTarget。
简单说明下这两个父对象的属性方法

<h3>EventTarget</h3>

<table>
<thead>
<tr>
  <th>方法</th>
  <th>功能</th>
</tr>
</thead>
<tbody>
<tr>
  <td>addEventListener()</td>
  <td>注册特定事件类型的事件处理程序</td>
</tr>
<tr>
  <td>removeEventListener()</td>
  <td>删除事件侦听器</td>
</tr>
<tr>
  <td>dispatchEvent()</td>
  <td>将事件分派到此EventTarget</td>
</tr>
</tbody>
</table>

EventTarget的简单实现

<pre><code>class EventTarget {
  constructor() {
    this.listeners = {};
  }

  addEventListener(type, callback) {
    if(!(type in this.listeners)) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(callback);
  }

  removeEventListener(type, callback) {
    if(!(type in this.listeners)) {
      return;
    }
    let stack = this.listeners[type];
    for (let i = 0, l = stack.length; i &lt; l; i++) {
      if(stack[i] === callback) {
        stack.splice(i, 1);
        return this.removeEventListener(type, callback);
      }
    }
  }

  dispatchEvent(event) {
    if(!(event.type in this.listeners)) {
      return;
    }
    var stack = this.listeners[event.type];
    event.target = this;
    for (let i = 0, l = stack.length; i &lt; 1; i++) {
      stack[i].call(this. event);
    }
  }
}
</code></pre>

<h3>XMLHttpRequestEventTarget</h3>

XMLHttpRequestEventTarget是一个描述事件处理程序的接口

<table>
<thead>
<tr>
  <th>属性</th>
  <th>功能</th>
</tr>
</thead>
<tbody>
<tr>
  <td>onabort</td>
  <td>当请求失败时调用该方法</td>
</tr>
<tr>
  <td>onerror</td>
  <td>当请求发生错误时调用该方法</td>
</tr>
<tr>
  <td>onload</td>
  <td>当一个HTTP请求正确加载出内容后返回时调用</td>
</tr>
<tr>
  <td>onloadstart</td>
  <td>当一个HTTP请求开始加载数据时调用</td>
</tr>
<tr>
  <td>onprogress</td>
  <td>间歇调用该方法用来获取请求过程中的信息</td>
</tr>
<tr>
  <td>ontimeout</td>
  <td>当时间超时（设置了timeout）时调用</td>
</tr>
<tr>
  <td>onloadend</td>
  <td>当内容加载完成（不管成功与否）时调用</td>
</tr>
</tbody>
</table>

<h3>XMLHttpRequest</h3>

<table>
<thead>
<tr>
  <th>属性</th>
  <th>功能</th>
</tr>
</thead>
<tbody>
<tr>
  <td>onreadystatechange</td>
  <td>当readyState属性发生变化时调用的EventHandler</td>
</tr>
<tr>
  <td>readyState</td>
  <td>请求的状态码</td>
</tr>
<tr>
  <td>responseType</td>
  <td>响应数据的类型</td>
</tr>
<tr>
  <td>response</td>
  <td>响应体，响应头类型取决于responseType</td>
</tr>
<tr>
  <td>responseURL</td>
  <td>响应的序列化URL</td>
</tr>
<tr>
  <td>responseXML</td>
  <td>一个Document，其中包含该请求的响应</td>
</tr>
<tr>
  <td>status</td>
  <td>返回无符号短整型请求响应状态</td>
</tr>
<tr>
  <td>statusText</td>
  <td>返回字符串型请求响应状态和信息</td>
</tr>
<tr>
  <td>timeout</td>
  <td>超时时间</td>
</tr>
<tr>
  <td>upload</td>
  <td>上传过程</td>
</tr>
<tr>
  <td>withCredentials</td>
  <td>用来指定跨域的请求是否应该使用证书</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
  <th>方法</th>
  <th>功能</th>
</tr>
</thead>
<tbody>
<tr>
  <td>abort()</td>
  <td>终止请求</td>
</tr>
<tr>
  <td>getAllResponseHeaders()</td>
  <td>以字符串的形式返回所有用CRLF分隔的响应头</td>
</tr>
<tr>
  <td>getResponseHeader()</td>
  <td>返回包含指定响应头的字符串</td>
</tr>
<tr>
  <td>open()</td>
  <td>初始化一个请求</td>
</tr>
<tr>
  <td>send()</td>
  <td>发送请求</td>
</tr>
<tr>
  <td>setRequestHeader()</td>
  <td>设置HTTP请求头的值</td>
</tr>
</tbody>
</table>

<h4>readyState的取值</h4>

<table>
<thead>
<tr>
  <th>值</th>
  <th>状态</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0</td>
  <td>UNSENT</td>
  <td>代理被创建，但尚未调用 open() 方法</td>
</tr>
<tr>
  <td>1</td>
  <td>OPENED</td>
  <td>open() 方法已经被调用</td>
</tr>
<tr>
  <td>2</td>
  <td>HEADERS_RECEIVED</td>
  <td>send() 方法已经被调用，并且头部和状态已经可获得</td>
</tr>
<tr>
  <td>3</td>
  <td>LOADING</td>
  <td>下载中； responseText 属性已经包含部分数据</td>
</tr>
<tr>
  <td>4</td>
  <td>DONE</td>
  <td>下载操作已完成</td>
</tr>
</tbody>
</table>

<h1>封装简单的Ajax方法</h1>

大概流程是：
1.通过兼容性判断创建XMLHttpRequest对象还是ActiveXObject对象
2.设置请求头，区分get与其他方法，调用open()，send()方法建立连接
3.每当 readyState 改变时，就会触发 onreadystatechange 事件。当 readyState 是 4 并且 status 是介于200（含）与400（不包含）之间时，可以获取到responseText。
4.用sent()方法发送请求

首先定义一下入参data

<table>
<thead>
<tr>
  <th>参数</th>
  <th>类型</th>
  <th>说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>option</td>
  <td>string</td>
  <td>请求方法</td>
</tr>
<tr>
  <td>url</td>
  <td>string</td>
  <td>请求地址</td>
</tr>
<tr>
  <td>body</td>
  <td>object</td>
  <td>请求参数</td>
</tr>
</tbody>
</table>

<pre><code>function ajax(data){
    // 创建对象
    var xhr = null;
    var params = formsParams(data.body);
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest()
    } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
    }
    // 设置请求头，建立连接
    if(data.option == "GET"){
        xhr.open(data.option, data.url + "?"+ params,data.async);
        xhr.send(null)
    } else if(data.option !== "GET"){
        xhr.open(data.option,data.url,data.async);
        xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
        xhr.send(params);
    }
    // onreadystatechange监听并相应
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 &amp;&amp; xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) {
          data.success(xhr.responseText);
        }
    }
    function formsParams(data){
        var arr = [];
        for(var prop in data){
            arr.push(prop + "=" + data[prop]);
        }
        return arr.join("&amp;");
    }

</code></pre>

<h1>实现Promise版的Ajax方法</h1>

其主要是返回一个Promise对象，把回调版的ajax的逻辑写入Promise中。

<pre><code>let ajax = ({url = '', option = 'get', body = {} }) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest()
    xhr.open(option, url, true);
    xhr.onreadystatechange = () =&gt; {
      if(xhr.readyState == 4 &amp;&amp; xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) {
        resolve(xhr.responseText);
      }
    }
    xhr.onerror = (error) =&gt; {
            reject(error);
        }
    xhr.send()
  });
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>250</wp:post_id>
		<wp:post_date><![CDATA[2019-04-20 14:28:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-20 06:28:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ajax%e5%85%a8%e6%8f%ad%e7%a7%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="http"><![CDATA[HTTP]]></category>
		<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[384]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript工作原理：内存管理</title>
		<link>http://bugzhang.com/?p=258</link>
		<pubDate>Thu, 23 May 2019 11:05:44 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=258</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>堆栈</h2>

js和其他语言一样，是将数据存储在堆栈结构中的。

<ul>
<li>栈（stack）：结构类似于数据结构中的栈，先入后出。存储了函数参数值、所有变量名包括对象的引用、基础类型（String、Number、Boolean、Null、Undefined、Symbol）。
<img src="http://img.bugzhang.com/queue.png" alt="" /></p></li>
<li><p>堆（heap）：结构类似于数据结构中的队列，先入先出，和操作系统中的堆（一种树）是完全的两码事。存储复杂对象。
<img src="http://img.bugzhang.com/stack.png" alt="" />
这里特别补充一点是池，又叫做常量池，顾名思义就是存储常量的地方，自从ES6引入const后，常量就被存储在池中。池是一块特殊的栈，结构和栈一样除了池中数据不可变之外。</p></li>
</ul>

<p>js的内存空间中的存储如下图
<img src="http://img.bugzhang.com/%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98.jpg" alt="" />

栈中的运算比堆中快，为什么要将Object存储在堆中是因为对象可拓展，单独存储不会影响栈的效率。

<h2>操作系统分配</h2>

静态分配：从静态存储区域分配内存。程序编译的时候内存已经分配好了，并且在程序的整个运行期间都存在，如静态变量和全局变量。

自动分配：在栈中为局部变量分配内存的方法，栈中的内存可以随着代码块退出时的出栈操作被自动释放。例如在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数结束时这些存储单元自动被释放。

动态分配：从静态存储区域分配内存。程序编译的时候内存已经分配好了，并且在程序的整个运行期间都存在，如静态变量和全局变量。

栈在底堆在上，function的执行都是通过入栈出栈，执行的时候去堆取到数据推入执行栈，成员变量在堆，局部变量在栈，全局变量也在堆；引用类型的引用变量存储在栈中，指向于实际存储在堆中的实际对象。

<h2>node.js中V8垃圾回收算法</h2>

<h3>新生代与老生代内存</h3>

新生代：存活时间较短的对象，会被GC自动回收的对象及作用域，比如不被引用的对象及调用完毕的函数等。默认吗32M。基本只包括抽象语法树中使用了的变量会被放在新生代中。

老生代：存活时间较长或常驻内存的对象，比如闭包因为外部仍在引用内部作用域的变量而不会被自动回收，故会被放在常驻内存中，这种就属于在新生代中持续存活，所以被移到了老生代中，还有一些核心模块也会被存在老生代中，例如文件系统(fs)、加密模块（crypto）等。可以依靠node --max-old-space-size修改，最大1.7G，默认1.4G。

具体内部的分类如下图：
<img src="http://img.bugzhang.com/5DL5K718A$3DT%60SPWC$LGKF.png" alt="" />

<h3>新生代的内存回收算法——Cheney算法</h3>

它将现有的空间分半，一个作为 To 空间，一个作为 From 空间，当开始垃圾回收时会检查 from 空间中存活的对象并赋复制入 To 空间中，而非存活就会被直接释放，完成复制后，两者职责互换，下一轮回收时重复操作。

算法效率很低，但占用空间大，但因为新生代本身内存限制不大，因此采用这样的算法对整个系统的优化是利大于弊的。

<h3>老生代的内存回收算法——标记清楚</h3>

当变量进度环境，将这个变量标记为“进入环境”，状态为“进入环境”的变量不会被释放，当变量离开环境，就标记为“离开环境”，并且进行回收。具体实现一般是翻转一个特定的位来实现这个标记。

<h3>被淘汰的内存回收算法——引用计数</h3>

引用计数在JavaScript内存回收中用的较少，现在只有KDE下的KJS引擎的游览器在采用，而最早是网景3游览器采用了这种方式。
引用计数的含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型赋值给变量时，引用次数是1.如果值又赋给另外一个变量，引用次数加1，如果包含这个值引用的变量取得了其他值，引用次数减1，当引用次数为0，表示不能再访问到，即可回收。
值得注意的是，虽然基本没有游览器上JavaScript使用引用计数了，但ie9一下游览器很多对象不是原生JavaScript对象，比如DOM与BOM中的对象就是c++以COM（组件对象模型）实现的，而COM的垃圾回收采用的是引用计数策略，因此即使游览器采用标记清楚实现垃圾回收，但只要在游览器设计COM对象，就使用了引用计数。这会引起循环引用的问题。如；

<pre><code>var ele = document.getElementById('ele');
var myObj = new Object();
myObj.ele = ele;  //新对象一个属性引用了com对象
ele.someObj = myObj;  ///com对象一个属性引用了JavaScript对象
</code></pre>

在上述情况下，即使将DOM从页面移除，其内存也不会被回收。为了避免出现，要在使用完毕后手工回收，赋值null来手工解除引用。
ie9以上的游览器上，BOM与DOM变成了JavaScript对象，不会再出现这个问题，但做兼容性处理的时候这种内存泄漏是要考虑的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>258</wp:post_id>
		<wp:post_date><![CDATA[2019-05-23 19:05:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-23 11:05:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[js%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[330]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript工作原理：JavaScript V8引擎的优化</title>
		<link>http://bugzhang.com/?p=262</link>
		<pubDate>Sat, 25 May 2019 17:14:56 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=262</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>
  js引擎是将JavaScript处理并运行的环境，jvm是java处理并运行的环境，在JavaScript的V8引擎的设计中，大量借鉴了jvm中的一些方法和思想进行设计，着重起到优化的功能
</blockquote>

<h2>编译性语言的处理过程</h2>

对于c或者c++这种编译兴来说，编辑、编译和运行是全部分离的，互相是一个职责链的形势，这个过程对于学过c语言基础或者与此相关的我们来说是非常简单的：
<img src="http://img.bugzhang.com/QQ%E5%9B%BE%E7%89%8720190812012318.png" alt="" />
如上图所示，编辑源代码后、经过编译链接、最后得到本地二进制代码，然后交给操作系统运行。

<h2>解释性语言的处理过程</h2>

对于python、ruby、perl等解释性语言（通常脚本语言都是解释性语言）来说，脚本并不需要进行编译，而是在运行过程中直接被解释器解释的同时调用操作系统资源运行的。旧的JavaScript引擎，也是采用这样的方式编译JavaScript代码的。

<img src="http://img.bugzhang.com/QQ%E5%9B%BE%E7%89%8720190812012324.png" alt="" />

如上图所示，比起编译性的语言，解释语言可以不用得到二进制表示，而被直接解释执行。

<h2>Java的处理过程</h2>

相比上边两种，Java的处理可谓复杂很多。分为了两个阶段：编译与解释阶段。与c++的编译阶段区别是编译阶段生产的不是直接可以运行的二进制代码，而是一种叫做字节码的中间代码。之所以使用这种字节码的中间代码是因为字节码可以不受操作系统和平台的限制，借助jvm实现“Write once, run anywhere”的跨平台功能，这也是Java最大的卖点与久经不衰的原因之一。

另外一个阶段是类似Python的解释阶段，Python不同的是：首先解释阶段将字节码作为了输入然后被解释器运行；加入了JIT的概念，JIT可以将字节码转为本地代码然后执行，这个JIT主要是起到一个优化性能的作用。
<img src="http://img.bugzhang.com/QQ%E5%9B%BE%E7%89%8720190812012327.png" alt="" />

<h2>V8对JavaScript的处理过程</h2>

V8对js的处理过程与Java非常相似，但把Java的两个阶段合并了起来，全部在JavaScript引擎中执行。此外，因为JavaScript作为弱类型语言，本身没有进行类型的标记，如果直接编译对于编译器来说是有性能损耗的，为此v8借用了类型系统在内部构建了隐性类型系统。

<img src="http://img.bugzhang.com/QQ%E5%9B%BE%E7%89%8720190812012331.png" alt="" />

<h2>多线程优化</h2>

V8引擎内部有多个线程进行处理：

<ul>
<li>主线程：获取代码并优化。</li>
<li>编译线程：获取主线程获取的代码然后编译并执行，此时主线程正在优化。</li>
<li>Profiler线程（我翻译为检查器线程）：找到会占用大量性能的部分，以便主线程可以优先优化这部分。</li>
<li>CG线程（垃圾扫描与回收器）：用来进行垃圾回收的线程。</li>
</ul>

首次执行JavaScript代码时，V8利用full-codegen直接将解析后的JavaScript转换为机器代码而无需任何转换。这使它可以非常快速地开始执行机器代码。请注意，V8不使用中间字节码表示，因此无需解释器。

当代码运行一段时间后，探查器线程已经收集了足够的数据来告诉应该优化哪个方法。

接下来，Crankshaft优化开始于另一个线程。它将JavaScript抽象语法树转换为名为Hydrogen的高级静态单指派（SSA）表示，并尝试优化氢图。大多数优化都是在这个级别完成的。

<h2>隐藏类优化</h2>

大多数JavaScript解释器使用类似字典的结构（基于散列函数）来存储对象属性值在内存中的位置。这种结构使得在JavaScript中检索属性的值比在Java或C＃等非动态编程语言中的计算成本更高。在Java中，所有对象属性都是在编译之前由固定对象布局确定的，并且无法在运行时动态添加或删除。结果、属性值（或指向这些属性的指针）可以作为连续缓冲区存储在存储器中，每个缓冲区之间具有固定偏移量。可以根据属性类型轻松确定偏移的长度，而在运行时可以更改属性类型的JavaScript中，这是不可能的。
由于使用字典在内存中查找对象属性的位置效率非常低，因此V8使用不同的方法：隐藏类。隐藏类的工作方式类似于Java等语言中使用的固定对象布局（类），除非它们是在运行时创建的。现在，让我们看看它们实际上是什么样的：

<pre><code>function Point（x，y）{ 
    this.x = x; 
    this.y = y; 
} 
var p1 = new Point（1,2）;
</code></pre>

一旦new一个新的Point类，V8将创建一个名为“C0”的隐藏类，如图：
<img src="http://img.bugzhang.com/1_pVnIrMZiB9iAz5sW28AixA.png" alt="" />
此时，尚未定义任何Point的属性，“C0”为空。

一旦执行了第一个语句“this.x = x”（在“Point”函数内），V8将创建一个名为“C1”的第二个隐藏类，它基于“C0”。“C1”描述了可以找到属性x的存储器中的位置（相对于对象指针）。在这种情况下，“x”存储在偏移 0处，这意味着当在存储器中查看点对象作为连续缓冲区时，第一偏移将对应于属性“x”。V8还将使用“类转换”更新“C0”，该类转换指出如果将属性“x”添加到点对象，则隐藏类应该从“C0”切换到“C1”。下面的点对象的隐藏类现在是“C1”。

<img src="http://img.bugzhang.com/1_QsVUE3snZD9abYXccg6Sgw.png" alt="" />

每次将新属性添加到对象时，旧的隐藏类都会更新为新隐藏类的转换路径。隐藏类转换很重要，因为它们允许在以相同方式创建的对象之间共享隐藏类。如果两个对象共享一个隐藏类并且同一属性被添加到它们中，则转换将确保两个对象都接收相同的新隐藏类以及随其附带的所有优化代码。

执行语句“this.y = y”时重复此过程。

创建一个名为“C2”的新隐藏类，将类转换添加到“C1”，声明如果将属性“y”添加到Point对象（已包含属性“x”），则隐藏类应更改为“C2”，点对象的隐藏类更新为“C2”。

<img src="http://img.bugzhang.com/1_spJ8v7GWivxZZzTAzqVPtA.png" alt="" />

隐藏类转换取决于属性添加到对象的顺序。看一下下面的代码片段：

<pre><code>function Point（x，y）{ 
    this.x = x; 
    this.y = y; 
} 
var p1 = new Point（1,2）; 
p1.a = 5; 
p1.b = 6; 
var p2 = new Point（3,4）; 
p2.b = 7; 
p2.a = 8;
</code></pre>

现在，您将假设对于p1和p2，将使用相同的隐藏类和转换。好吧，不是真的。对于“p1”，首先添加属性“a”，然后添加属性“b”。但是，对于“p2”，首先分配“b”，然后是“a”。因此，作为不同转换路径的结果，“p1”和“p2”以不同的隐藏类结束。在这种情况下，<strong>以相同的顺序初始化动态属性要好得多，以便可以重用隐藏的类。</strong>

<h2>内联缓存</h2>

除了JIT、多线程、隐藏类外，V8还是用来内联缓存的方式优化js这种动态语言代码。内联缓存依赖于<strong>对相同类的对象的重复调用往往发生在相同类的对象上</strong>这一常见的现象。即A类的对象往往会重复调用B类的对象，V8会维护一个作为参数传递的对象类型的缓存，并且以B类为假设的对象类型。之后如果判断得到V8猜想正确，那么就可以绕过访问对象属性的过程。

每当在特定对象上调用方法时，V8引擎必须执行对该对象的隐藏类的查找，以确定访问特定属性的偏移量。在将同一方法成功调用两次到同一个隐藏类之后，V8省略了隐藏类查找，只是将属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8引擎假定隐藏类未更改，并使用先前查找中存储的偏移直接跳转到特定属性的内存地址。这大大提高了执行速度。

<h2>新的管道机制</h2>

新的执行管道建立在Ignition，V8的解释器和TurboFan（V8的最新优化编译器）之上。也大大提升了性能。以下两张图是在引入Ignition前后，V8对于管道的使用过程。
<img src="http://img.bugzhang.com/918GZ8F$%28MIH3Q_UR%7D74%7D$C.png" alt="" />
<img src="http://img.bugzhang.com/BVJ~S%5D3%5B%5D%7B%60G%5D4SKDAIY5NG.png" alt="" />

<hr />

参考：

<ul>
<li>chrome官方文档：https://docs.google.com/
-https://docs.google.com/presentation/d/1chhN90uB8yPaIhx_h2M3lPyxPgdPmkADqSNAoXYQiVE/edit#slide=id.g1ba7f92079_5_29</li>
<li>《webkit技术内幕》</li>
<li>https://blog.csdn.net/allen8612433/article/details/80329022</li>
<li>https://blog.csdn.net/zhangge3663/article/details/83310757</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>262</wp:post_id>
		<wp:post_date><![CDATA[2019-05-26 01:14:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-25 17:14:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript-v8%e5%bc%95%e6%93%8e%e4%b8%8ejava-jvm%e5%af%b9%e6%af%94]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[223]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript工作原理：五种JavaScript代码的优化方式</title>
		<link>http://bugzhang.com/?p=268</link>
		<pubDate>Wed, 12 Jun 2019 07:45:02 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=268</guid>
		<description></description>
		<content:encoded><![CDATA[在了解这些优化方式前，先强烈建议阅读本博客前两篇文章，前两篇是对V8原理的一个入门，因为这些优化方式，都是针对原理而引入的可行方式。

<h2>对象属性的顺序</h2>

始终以相同的顺序实例化对象属性，以便可以共享隐藏的类和随后优化的代码。

<pre><code>// bad
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var a = new Point(1,2);
var b = new Point();  // 顺序不一致
b.x = 2;
b.y = 1;

// good 
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var a = new Point(1,2);
var b = new Point(2,1);
</code></pre>

<h2>动态属性</h2>

在实例化之后向对象添加属性或者修改属性的类，都会修改隐藏类，使得优化无效。所以对象实例化时尽量添加好属性，并且尽量不再做对属性类型的修改。

<pre><code>// bad
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var a = new Point(1,2);
var b = new Point(2,1);
b.z = 3; // 实例化后添加了属性
a.y = null // 实例化后修改了类型

// good 
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var a = new Point(1,2);
var b = new Point(2,1);
</code></pre>

<h2>对象的方法</h2>

对同一个类new出来的对象多次执行同一个方法，第一次后的执行速度会非常快，因为内联缓存。

<pre><code>// bad
function Rectangle(x, y) {
    this.x = x;
    this.y = y;
}
function Square(a) {
    this.a = a;
}

var a = new Rectangle(1, 2);
var b = new Square(2);
function SquareArea(square) {
    var a = square.a;
    return a * a;
}
function RectangleArea(rectangle) {
    var x = rectangle.x;
    var y = rectangle.y;
    return x * y;
}

// good
function Rectangle(x, y) {
    this.x = x;
    this.y = y;
}
function Area (rectangle) {
    var x = rectangle.x;
    var y = rectangle.y;
    return x * y;
}
var a = new Rectangle(1, 2);
var b = new Rectangle(2, 2);
var b = new Rectangle(5, 6);
Area(a);
Area(b);
Area(c);
</code></pre>

<h2>内存回收</h2>

有效使用内存总是可以提高代码的性能，对于使用了垃圾回收的语言来说，并不意味着有了垃圾回收就没有内存泄漏的问题，如果及时回收不再使用的内存，可以避免内存泄漏的同时减轻编译器的工作。简单的做法就是把不再使用的对象设置为null，以及通过delete关键字，来删除对象的一个属性。

<h2>数组</h2>

避免稀疏数组，其中键值不是自增的数字。并没有存储所有元素的稀疏数组是哈希表。这种数组中的元素访问开销较高。另外，尽量避免预分配大数组。最好是按需增长。最后，不要删除数组中间的元素，即使用队列和栈方法删除。这会使键值变得稀疏。

<pre><code class="bad">var a = [];
a[0] = 1;
a[5] = 2; // 稀疏数组

var b = [];
b.length = 10000; // 预先分配了大数组

var c = [1,2,3,4,5];
c[3] = undefined; // 删除后变为稀疏数组
</code></pre>

<h2>数据表示</h2>

V8 使用 32 位表示对象和数值。由于数值是 31 位的，它使用了一位来区分它是一个对象（flag = 1）还是一个称为 SMI（SMall Integer）整数（flag = 0）。那么，如果一个数值大于 31 位，V8会将该数字装箱，把它变成一个双精度数，并创建一个新的对象来存放该数字。尽可能使用 31 位有符号数字，以避免对 JS 对象的高开销的装箱操作。

V8 的简单数据存放在句柄，句柄的操作是非常快的，而对大整数和大浮点数会使用堆，因为大整数是不可避免的，所以能使用整数的，尽量不要使用浮点数。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>268</wp:post_id>
		<wp:post_date><![CDATA[2019-06-12 15:45:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-12 07:45:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%94%e7%a7%8djavascript%e4%bb%a3%e7%a0%81%e7%9a%84%e4%bc%98%e5%8c%96%e6%96%b9%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[137]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>游览器工作原理：HTML的渲染</title>
		<link>http://bugzhang.com/?p=272</link>
		<pubDate>Wed, 14 Aug 2019 15:36:14 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=272</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>
  我们已经熟悉JavaScript提供的一套Dom模型和接口来操作网页元素。这篇文章主要解释作为游览器核心的dom部分如何被表示、渲染和处理。
</blockquote>

<h2>DOM模型</h2>

DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 
解析树的根节点是“Document”对象。HTML中的Tag也是一种节点，称为元素节点；此外，主要的节点还有属性节点、注释节点等。

DOM 与节点之间几乎是一一对应的关系。比如下面这段HTML：

<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Hello World
    &lt;/p&gt;
    &lt;div&gt; &lt;img src="example.png"/&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

被转移为DOM树的结果是：

<pre><code>                  +---------------------+
                  |   HTMLHtmlElement   |
                  +---------+-----------+
                            |
                            |
                            |
                  +---------+-----------+
                  |   HTMLBodyElement   |
                  +---------------------+
                            X
                           X X
                          X   X
                         X     X
+------------------------+      +--------------------+
|  HTMLParagraphElement  |      |   HTMLDivElement   |
+-------------+----------+      +----------+---------+
              |                            |
              |                            |
              |                            |
        +-----+----+            +----------+---------+
        |   Text   |            |  HTMLImageElement  |
        +----------+            +--------------------+

</code></pre>

<h2>HTML解释器</h2>

游览器获取到HTML资源后的整体处理过程如下：

<img src="http://img.bugzhang.com/20190813234838.png" alt="" />

<h3>词法分析</h3>

词法解析主要是将字符流转换为词语（tokens）。在webkit内部有一个HTMLTokenizer的类完成词法分析的工作。主要提供一个nextToken方法，这个方法非常复杂，简单描述一下：

这个算法相对于一个状态机。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。最终输出结果是 HTML Token。

对于以下的一段HTML代码：

<pre><code>&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

1.初始状态是<strong>数据状态</strong>。

2.遇到字符 &lt; 时，状态更改为<strong>标记打开状态</strong>。

3.接收一个 a-z 字符会创建<strong>起始标记</strong>，状态更改为<strong>标记名称状态</strong>。这个状态会一直保持到接收 > 字符。在此期间接收的每个字符都会附加到新的标记名称上。

4.遇到 > 标记时，会发送当前的标记，状态改回<strong>数据状态</strong>。<code>&lt;body&gt;</code> 标记也会进行同样的处理

5.接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 <code>&lt;/body&gt;</code> 中的 &lt;。我们将为 Hello world 中的每个字符都发送一个字符标记。

6.接收下一个输入字符 / 时，会创建 end tag token 并改为<strong>标记名称状态</strong>。我们会再次保持这个状态，直到接收 >。然后将发送新的标记，并回到<strong>数据状态</strong>。<code>&lt;/html&gt;</code> 输入也会进行同样的处理。

<img src="http://img.bugzhang.com/20190814152158.png" alt="" />

<h3>语法分析</h3>

在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为<strong>插入模式</strong>。

然后状态将改为<strong>before head</strong>。此时我们接收<code>body</code>标签。即使我们的示例中没有<code>head</code>标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。

现在进入了<strong>in head</strong>模式，然后转入<strong>after head</strong>模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为<strong>in body</strong>。

现在，接收由<strong>Hello world</strong> 字符串生成的一系列字符标记。接收第一个字符时会创建并插入<strong>Text</strong>节点，而其他字符也将附加到该节点。

接收 body 结束标记会触发<strong>after body</strong>模式。现在我们将接收 HTML 结束标记，然后进入<strong>after after body</strong>模式。接收到文件结束标记后，解析过程就此结束。

<img src="http://img.bugzhang.com/20190814152026.png" alt="" />

<h2>浏览器的容错机制</h2>

在早些年写html的过程中，我经常纳闷为什么我写的很多并不规范，也被正常解析，例如只写了一个<code>&lt;br&gt;</code>和<code>&lt;/br&gt;</code>，用错了标准的标记等等。HTML 网页时从来不会有语法无效的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。

例如以下HTML代码：

<pre><code>&lt;html&gt;
  &lt;mytag&gt;
  &lt;/mytag&gt;
  &lt;div&gt;
  &lt;p&gt;
  &lt;/div&gt;
    Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;
</code></pre>

这段代码已经违反了很多语法规则：“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等。但是因为容错机制的存在，浏览器仍然会正确地显示这些内容。

解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。

遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。

我们至少要能够处理以下错误情况：

1.明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。

2.我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。

3.向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。

4.如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。

<h2>线程化的解释器</h2>

线程化的解释器就是利用单独的线程来解释 HTML 文档。因为在WebKit中，网络资源的字节流自IO线程传递给渲染线程之后，后面的解释、布局、渲染都工作在该线程。
DOM树必须是单独的线程，但从字节流到tokens的阶段可以由单独的线程去做这个工作，为了提升性能。

<hr />

参考：
http://www.w3.org/TR/html5/syntax.html#html-parser
https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_HTML_grammar_definition]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>272</wp:post_id>
		<wp:post_date><![CDATA[2019-08-14 23:36:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-08-14 15:36:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b8%b8%e8%a7%88%e5%99%a8%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%9ahtml%e7%9a%84%e6%b8%b2%e6%9f%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="webkit"><![CDATA[webkit]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%b8%b8%e8%a7%88%e5%99%a8"><![CDATA[游览器]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_0c633bc52db36d5a0d47d2334e8970f0]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_f183f86a8e13745a4fb10b93eb4959eb]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[150]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>JavaScript工作原理：事件循环</title>
		<link>http://bugzhang.com/?p=275</link>
		<pubDate>Mon, 24 Jun 2019 13:19:22 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=275</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>单线程异步</h2>

js早期对性能无要求，与此一开始就采用了单线程的选择，好处显而易见是可以非常清晰的确定执行顺序，如果多线程则很难判断在需要某个值时其他是否处理完毕。

虽然后来引入了web service，但其主线程一直是单线程的，并且主线程的变量不得操作dom，辅助线程仍然受主线程控制，相对于对主线程进行辅助计算。

引入异步是，避免某个延时任务（如定时器）阻塞了整个进场，使得加载和渲染无法继续下去，如果没有异步的话，在单线程的js中一旦延时，那么必须要等到这个定时器执行完才可以继续进行渲染或者其他操作，这在客户端基本是不可容忍的。

<h2>执行栈</h2>

执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则

<img src="http://img.bugzhang.com/1670d2d20ead32ec.gif" alt="" />

js代码的执行过程就是往执行栈里放入函数然后先进后出的执行。

<h2>任务队列</h2>

JavaScript将任务分为两类：同步任务和异步任务。同步任务会直接进入调用栈先进后出的执行，而异步任务则会放入任务队列，一旦执行栈为空，EventLoop会从任务队列中取出应该被执行的任务放入执行栈执行，<strong>本质上异步代码也是同步执行的</strong>。

<img src="http://img.bugzhang.com/16740fa4cd9c6937.webp" alt="" />

将异步任务又分为了两类：宏任务（macrotask）和微任务（microtask）。执行顺如如下：

1.首先执行同步代码，这属于宏任务

2.当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行

3.执行所有微任务

4.当执行完所有微任务后，如有必要会渲染页面

5.然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数

微任务包括 process.nextTick ，promise ，MutationObserver。

宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。

一个常考是示例：

<pre><code>console.log('script start')

async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end')
}
async1()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve =&gt; {
  console.log('Promise')
  resolve()
})
  .then(function() {
    console.log('promise1')
  })
  .then(function() {
    console.log('promise2')
  })

console.log('script end')

// 执行顺序是：
// script start
// async2 end
// Promise
// script end
// promise1
// promise2
// async1 end
// setTimeout
</code></pre>

<h2>node.js中的事件循环</h2>

node.js的异步机制是采用了libuv这个c++的异步库实现的，因此其时间循环就是libuv中规定是循环——分为六个阶段执行：

<pre><code>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre>

<ul>
<li><strong>timers</strong>

<ul>
<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行。</li>
<li>检查是否有 process.nextTick 任务，如果有，全部执行。</li>
<li>检查是否有microtask，如果有，全部执行。</li>
</ul></li>
<li><strong>pending callbacks</strong>

<ul>
<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段。</li>
<li>检查是否有 process.nextTick 任务，如果有，全部执行。</li>
<li>检查是否有microtask，如果有，全部执行。</li>
</ul></li>
<li><strong>idle, prepare</strong>

<ul>
<li>libuv内部为poll做准备工作。</li>
</ul></li>
<li><strong>poll</strong>

<ul>
<li>首先检查是否存在尚未完成的回调。如果有未完成回调：</li>
<li>如果有未完成回调。

<ul>
<li>执行所有可用回调。</li>
<li>检查是否有 process.nextTick 回调，如果有，全部执行。</li>
<li>检查是否有微任务，如果有，全部执行。</li>
</ul></li>
<li>如果没有未完成回调 

<ul>
<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知重启循环。</li>
</ul></li>
<li>如果不存在尚未完成的回调，退出poll阶段。</li>
</ul></li>
<li><strong>check</strong>

<ul>
<li>如果有immediate回调，则执行所有immediate回调。</li>
<li>检查是否有 process.nextTick 回调，如果有，全部执行。</li>
<li>检查是否有 microtaks，如果有，全部执行。</li>
</ul></li>
<li><strong>close callbacks</strong>

<ul>
<li>如果有immediate回调，则执行所有immediate回调。</li>
<li>检查是否有 process.nextTick 回调，如果有，全部执行。</li>
<li>检查是否有 microtaks，如果有，全部执行。</li>
</ul></li>
</ul>

上述过程比较复杂，对于一个实际的问题而言，自从node.js升级到10后，执行顺序其实是和游览器端一致的，所以不需要非常详细的知道上述过程，安装与游览器游览器端的去编码即可。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>275</wp:post_id>
		<wp:post_date><![CDATA[2019-06-24 21:19:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-06-24 13:19:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%9a%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="javascript"><![CDATA[JavaScript]]></category>
		<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[279]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>游览器工作原理：CSS的渲染</title>
		<link>http://bugzhang.com/?p=310</link>
		<pubDate>Sun, 08 Sep 2019 16:42:25 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=310</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>CSS样式规则</h1>

<pre><code class="html">&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        div {
            positon: absolute;
            top: 200px;
            left: 200px;
            width: 200px;
            height: 200px;
            border: 2px solod black;
            padding:20px;
            background-color: blue;
            color: green;
            opacity: 0.8;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="simple"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

上边是一个使用CSS的简单例子，所有的CSS都是按照以下规则书写的：

<strong>[选择器] { [样式名]: [样式值], [样式名]: [样式值], ...}</strong>

<h1>位置计算</h1>

CSS的位置计算包含了两大部分，一部分是众所周知的 盒子模型，另外一部分是比较小众的 包含块模型。对于盒子模型，因为比较简单，本篇博文略过，重点讲 包含块模型。

当游览器计算元素的盒子的位置和大小时，webkit需要计算该元素和另外一个矩形区域的相对位置，这个矩形区域称为该元素的包含块。盒模型就是在包含块内计算和确定各个元素的。

<ul>
<li>根元素的包含块称为初试包含块，大小就是可视区域。</li>
<li>对于static和relative布局的元素，包含块是最佳父级元素盒子模型的content区域。</li>
<li>对于fixed布局的元素，包含块脱离html流，固定值整个游览器可视区域的一个位置。</li>
<li>对于absolute布局的元素，包含块由最近含有absolute、relative、fixed的祖先决定：如果一个元素具有inline属性，元素的包含块是包含该祖先的第一个和最后一个内联元素的内边距的区域；否则，包含块是该祖先的内边距的区域。</li>
</ul>

<h1>CSSOM：CSS对象模型</h1>

可能所有人都知道HTML对应的文档对象模型的DOM，但没多少听过CSS对应CSS对象模型 CSSOM 。实际当游览器要解析外联或者内联的CSS时，为了可以解析这种文档，使之可以用于样式排布和绘制。这种数据结构就是 CSSOM。它的思想是在DOM的一些节点接口中，加入获取和操作CSS属性或者接口的javascript接口，因而实现让javascript可以动态操作CSS样式。

对于样式表，CSSOM提供了一个接口，这个接口在webkit定义是：

<pre><code class="c">partial interface Document {
    readonly attribute StyleSheetList styleSheetLists;
    attribute DOMString ? sekectedStyleSheetSet;
    readonly attribute DOMString ? lastStyleSheetSet;
    readonly attribute DOMString ? preferredStyleSheetSet;
    readonly attribute DOMString ? StyleSheeSetsList styleSheetLists;
    void enableStyleSheetsForSet(DOMString ? name);
}
</code></pre>

通过这些属性，可以动态选择使用哪些样式表。
这个接口可以获取样式表的各种信息，例如css的'href'、css类型'type'、css规则'cssRules'。使用方法是document.stylesheets，可以得到如下结果：
<img src="http://img.bugzhang.com/DOMStringDOMString.jpg" alt="CSSOM" />

<h1>CSS解释器与匹配规则</h1>

CSS的解释分为三个过程

词法分析：
在上一章节第一节中，简单说了样式规则，在webkit内部，
样式类型有以下几个Class：

<ul>
<li>Style：基本类型，绝大多数属于这个类型</li>
<li>Import：引入CSS用</li>
<li>Media：对应 @media 类型</li>
<li>Fontface：CSS3中自定义字体的类型</li>
<li>Keyframes：对应css3中 @keyframes 类型</li>
<li>Page：对应 @page 类型</li>
</ul>

这些样式和值对应的 CSSValue 这个类组成了一个样式规则——被叫做CSSProperly，同一个选择器 CSSSelector 多个样式规则一起组成了 CSSPropertySet。于是形成了如下结构：

<img src="http://img.bugzhang.com/CSSProperly.jpg" alt="" />

这些结构的每个节点就是 <strong>token</strong>

语法分析：由 CSSParser 类完成，但这个类是一个代理模式，实际完成的是 CSSGrammer 类完成，这个类可以解析startSelector, endSelector, startRuleBody, startProperty, parseValue, endRuleBody。

结果这两步，就生成样式规则StyleRule，会被放入 StyleSheetContents 对象中。

<h1>CSS布局计算</h1>

布局计算是一个递归的过程，每一个节点的大小都要计算其子女的位置和大小。布局计算依靠内部类 RenderObject 进行计算。整个过程如下：

<img src="http://img.bugzhang.com/webkitLayout" alt="" />

对于以下几种情况会触发重新布局：

<ul>
<li>当网页首次被打开的时候，游览器设置网页的可视区域，并调用计算布局的方法；</li>
<li>网页的动画会触发布局计算，因为动画可能改变样式属性；</li>
<li>JavaScript代码通过CSSOM等直接修改样式信息；</li>
<li>用户的交互，例如翻滚网页。
重新布局就是所谓的回流，因为不能依靠修改单纯内存中的CSSValues然后调用渲染器实现修改，必须经过布局计算全部计算并渲染，因此非常消耗时间，也是前端老生常谈的优化项之一。</li>
</ul>

游览器在进行完布局计算后，还会进行布局测试，布局测试是对游览器最重要的测试，它会测试整个网页的渲染结果，包括网页的加载和渲染两个过程。方法是预先准备大量运用测试渲染结果的单元测试用例，然后把得到的结果和已有的用例进行比对检测准确性。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>310</wp:post_id>
		<wp:post_date><![CDATA[2019-09-09 00:42:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-08 16:42:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b8%b8%e8%a7%88%e5%99%a8%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%9acss%e7%9a%84%e6%b8%b2%e6%9f%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%b8%b8%e8%a7%88%e5%99%a8"><![CDATA[游览器]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[127]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>时序数据库Influxdb入门</title>
		<link>http://bugzhang.com/?p=313</link>
		<pubDate>Thu, 12 Sep 2019 12:06:37 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=313</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

InfluxDB是一个时间序列数据库，旨在处理高写入和查询负载。它是TICK堆栈的组成部分。InfluxDB旨在用作涉及大量带时间戳数据的任何用例的后备存储，包括DevOps监控，应用程序指标，物联网传感器数据和实时数据分析。

<h1>特点</h1>

InfluxDB具备以下特点：

<ul>
<li>专为时间序列数据编写的自定义高性能数据存储。TSM引擎允许高摄取速度和数据压缩</li>
<li>完全写在Go。它编译成单个二进制文件，没有外部依赖项。</li>
<li>简单，高性能的写入和查询HTTP API。</li>
<li>插件支持其他数据提取协议，如Graphite，collectd和OpenTSDB。</li>
<li>为类似SQL的查询语言量身定制，可轻松查询聚合数据。</li>
<li>标签允许对系列进行索引以实现快速有效的查询。</li>
<li>保留策略有效地自动使过时数据过期。</li>
<li>连续查询自动计算聚合数据，以提高频繁查询的效率。</li>
</ul>

<h1>安装</h1>

在mac上的安装使用brew

<pre><code class="shell">brew update
brew install influxdb
ln -sfv /usr/local/opt/influxdb/*.plist ~/Library/LaunchAgents

# 配置文件在/etc/influxdb/influxdb.conf ，如果没有就将/usr/local/etc/influxdb.conf 拷一个过去
配置缓存：cache-max-memory-size

#启动服务
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.influxdb.plist

#停止服务
launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.influxdb.plist

#前台启动
influxd -config /usr/local/etc/influxdb.conf

#查看influxdb运行配置
influxd config

#启动交互式客户端
influx -precision rfc3339

</code></pre>

<h1>基本概念</h1>

以一个表格来说明和传统关系数据库的对比。

<table>
<thead>
<tr>
  <th>influxDB中的名词</th>
  <th align="center">传统数据库中的概念</th>
</tr>
</thead>
<tbody>
<tr>
  <td>database</td>
  <td align="center">数据库</td>
</tr>
<tr>
  <td>measurement</td>
  <td align="center">数据库中的表</td>
</tr>
<tr>
  <td>points</td>
  <td align="center">表里面的一行数据　</td>
</tr>
</tbody>
</table>

以一个示例来说明中的数据。

<table>
<thead>
<tr>
  <th>time</th>
  <th align="center">butterflies</th>
  <th align="center">honeybees</th>
  <th align="center">location</th>
  <th align="right">scientist</th>
</tr>
</thead>
<tbody>
<tr>
  <td>2015-08-18T00:00:00Z</td>
  <td align="center">12</td>
  <td align="center">23</td>
  <td align="center">1</td>
  <td align="right">langstroth</td>
</tr>
<tr>
  <td>2015-08-18T00:00:00Z</td>
  <td align="center">1</td>
  <td align="center">30</td>
  <td align="center">1</td>
  <td align="right">perpetua</td>
</tr>
<tr>
  <td>2015-08-18T00:06:00Z</td>
  <td align="center">11</td>
  <td align="center">28</td>
  <td align="center">1</td>
  <td align="right">langstroth</td>
</tr>
<tr>
  <td>2015-08-18T00:06:00Z</td>
  <td align="center">3</td>
  <td align="center">28</td>
  <td align="center">1</td>
  <td align="right">perpetua</td>
</tr>
</tbody>
</table>

<strong>time</strong>是时间(time)，具体格式必须是一个时间戳或者RFC3339时间。

<strong>butterflies</strong>、<strong>honeybees</strong>是字段（field），包括字段键（表头）和字段值（表格内容）。

、<strong>location</strong>、<strong>scientist</strong>是标签（tag），同样包括了标签建（表头）和标签值（表格内容）。注意标签和字段第一眼看上去非常相似，其区别是标签是一个类似枚举的结构，只有几种可选的标签值。这与字段不同，标记是索引的。这意味着标签上的查询更快，并且该标签非常适合存储常用查询元数据。

在influxDB中，有个叫做series的概念，这个series是数据可视化中的数据，是通过tags排列组合出来的。一般在echarts等库中也可以看到相似的概念。

<h1>基本操作</h1>

<h2>数据库操作</h2>

<pre><code class="sql">/*创建数据库*/
CREATE DATABASE mydb

/*使用数据库*/
use DATABASE mydb

/*删除数据库*/
drop DATABASE mydb
</code></pre>

<h2>数据measurement的操作</h2>

<pre><code>/*插入数据：插入了一条数据*/
insert testTable&lt;表名字&gt;, butterflies=3 ,honeybees=28 , location=1 ,scientist=perpetua&lt;内容&gt;
/*查询数据：查询最近的3条数据*/
SELECT * FROM weather ORDER BY time DESC LIMIT 3
</code></pre>

<h2>HTTP接口</h2>

InfluxDB直接提供了一套HTTP接口，部分操作如下：

<pre><code class="shell"># 插入数据：插入了一条数据
curl -i -XPOST 'http://localhost:8086/write?db=myDB' --data-binary 'testTable, butterflies=3 ,honeybees=28 , location=1 ,scientist=perpetua'

# 查询数据：查询最近的3条数据
curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode "db=myDB" --data-urlencode "q=SELECT * FROM testTable ORDER BY time DESC LIMIT 3"
</code></pre>

<h2>node.js中的实用</h2>

目前已经有第三方的npm包，所以在node.js中也非常方便

<pre><code class="javascript">/**@type InfluxDB*/
var influx = require('influx')
var async = require("async")
var ut = require("./../../util/util.js")
var dbName = "mydb"
var tableName = "testTable"
var client = influx({
    host : '0.0.0.0',
    port : 8086, // optional, default 8086
    protocol : 'http', // optional, default 'http'
    username : '',
    password : '',
    database : mydb
})
var altitudes = [1000, 5000]
var areas = ["北", "上", "广", "深"]
async.waterfall([
        function(cb){ // 创建数据库
            client.createDatabase(dbName, function(err,result){
                ut.log("createDatabase", result)
                cb(err, null)
            } )
        },
        function(result, cb){ // 获取数据库名字
            client.getDatabaseNames( function(err, result){
                ut.log("getDatabaseNames", result)
                cb(err, null)
            } )
        },
        function(result, cb){ // 写入数据
            var points = [
                [
                    {
                        temperature: ut.RandByRange(0, 100), humidity : ut.RandByRange(-15, 30)
                    },
                    {
                        altitude: altitudes[ut.RandByRange(0, altitudes.length)], area : areas[0]
                    },
                ],
                [
                    {
                        temperature: ut.RandByRange(0, 100), humidity : ut.RandByRange(-15, 30)
                    },
                    {
                        altitude: altitudes[ut.RandByRange(0, altitudes.length)], area : areas[1]
                    },
                ],
            ]
            client.writePoints(tableName, points, function(err, result){
                ut.log("writePoint", result)
                cb(err, null)
            } )
        },
        function(result, cb){ // 查询数据
            client.query( 'SELECT * FROM weather ORDER BY time DESC LIMIT 3', function(err,result){
                ut.log("query", result)
                cb(err, null)
            } )
        },
        function(result, cb){
            client.getMeasurements( function(err,result){
                ut.log("getMeasurements", JSON.stringify(result))
                cb(err, null)
            })
        }
    ]
    , function(err, result){
        ut.log("finish...", err, result)
    }
)
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>313</wp:post_id>
		<wp:post_date><![CDATA[2019-09-12 20:06:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-09-12 12:06:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%97%b6%e5%ba%8f%e6%95%b0%e6%8d%ae%e5%ba%93influxdb%e5%85%a5%e9%97%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[149]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>前端代码风格指南——javascript篇</title>
		<link>http://bugzhang.com/?p=317</link>
		<pubDate>Tue, 20 Nov 2018 12:17:27 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=317</guid>
		<description></description>
		<content:encoded><![CDATA[<ul>
<li>严格模式：开启（必须）

<blockquote>
  理由：能够避免一些不精通js特性导致的坑，如==和===，得益于js早期糟糕的设计，有太多这样的问题。需要注意的是，严格模式在ie9下不兼容，但该项目是vue体系项目至少运行在ie10以上故不需要考虑。
</blockquote></li>
<li>引号：一律使用单引号（必须）

<blockquote>
  理由：可以和html的双引号更好的工作
</blockquote></li>
<li>分号：一律在语句结尾加分号（必须）

<blockquote>
  理由：首先官方新规范是要求分号的，可以避免不必要的坑。
</blockquote>

<pre><code class="js">/* 不推荐的 */
let fn = {
return 0
}

/* 推荐的 */
let fn = {
return 0;
}; //这里有分号
</code></pre></li>
<li>空白与格式（必须）</li>
</ul>

在二元和三元运算符的符号与操作数之间添加空格，在非行末的 , ; } 后添加空格，在 { 前添加空格。并在每个逻辑块中间添加空白行。
特别的，在 if、while 等关键字后加空格，与函数调用做区分

<pre><code class="js">/* 不推荐的 */
let foo='bar',hello=foo+2,test=true;
function hi(){
  // ...
}
if(foo&amp;&amp;hello){
  // ...
}else if(foo){
  // ...
}else if(! test){
  // ...
}

/* 推荐的 */
let foo = 'bar';
let hello = foo + 2;
let test = true;
function hi(arg1, arg2) {
  // ...
}
if (foo &amp;&amp; hello) {
  // ...
} else if (foo) {
  // ...
} else if (!test) {
  // ...
}
</code></pre>

<ul>
<li>变量声明（必须）

<ul>
<li>一个函数作用域中所有的变量声明尽量提到函数首部。</li>
<li>如果可以使用 let 和 const 的，要使用 let 和 const。</li>
<li>除了特殊情况如挂载全局jquery等外，不要定义全局变量。
> 理由：第一条是保证可读性，第三条和第四条是安全的作用域，</li>
</ul></li>
<li>变量命名（必须）

<ul>
<li>变量全部使用小驼峰，如</li>
<li>常量使用大写匈牙利式命名法，如MAX_COUNT</li>
<li>组件名必须为多个单词，如ConfigCenter</li>
<li>组件名使用大驼峰命名，如ConfigCenter</li>
<li>构造函数与类，大写第一个字母，如Person()</li>
<li>jquery 对象必须以'$'开头命名</li>
<li>对象私有属性和方法，用'#'开头命名</li>
<li>不要使用复数，对于变量而言，复数还是非负数都一样
> 理由：可读性好，实际这是js与vue.js官方推荐的命名方式整合。</li>
</ul>

<pre><code class="js">/* 推荐的 */
var thisIsMyName; // 变量
var MAX_COUNT = 10; // 常量
function Person(name) { // 构造函数
this.name = name;
}
var $body = $("body"); // jquery对象
class Point { // 类
#x; // 私有属性
#y;

constructor(x, y) {
  this.#x = x;
  this.#y = y;
}
}
</code></pre></li>
<li>括号（可选）</p></li>
</ul>

<p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。大括号如果是单行，前后要加一个空格。

<blockquote>
  理由：能够避免一些bug，提升可读性，方便复制代码而不复制到括号。
</blockquote>

<pre><code class="js">/* 不推荐的 */
if (condition) doSomething();

/* 推荐的 */
if (condition) { doSomething() };
import { x, y } from myModule;
</code></pre>

<ul>
<li>对于循环和判断代码，不要循环或判断三层以上。（可选）</p></li>
<li><p>能用ES6、ES7等新版本ES语法的，尽量用新语法，包括不仅限于：（部分必须）

<ul>
<li>使用对象和数组的解构赋值的方式实现多个变量的赋值。</li>
</ul>

<pre><code class="js">/* 不推荐的 */
let [a, b, c] = [1, 'a', [ 2 , 3]]

/* 推荐的 */
let []
</code></pre>

<ul>
<li>使用拓展运算符...对参数对象中的所有可遍历属性进行拷贝。</p></li>
<li><p>小函数使用箭头函数来替代function，这里要注意箭头函数作用域问题。</p></li>
<li><p>使用字符串模板进行字符串拼接。</p></li>
<li><p>使用安全的块级作用域语法let和const。</p></li>
<li><p>使用Object.assign()进行对象的浅拷贝。</p></li>
<li><p>使用Set去重，以及替代元素不重复的数组。</p></li>
<li><p>使用class语法替代原有的方式。</p></li>
<li><p>使用函数参数的默认值替代 || 语法</p></li>
</ul>

<pre><code class="js">/* 不推荐的 */
function f(x, y, z) {
y = 1 || undefined;
z = 2 || undefined
return x + y + z;
}

/* 推荐的 */
function f1(x, y = 4, z = 12) {
return x + y + z;
}
</code></pre>

<ul>
<li>使用对象中函数的缩写形式</li>
</ul>

<pre><code class="js">/* 不推荐的 */
let obj = {
add: function() {}
}

/* 推荐的 */
let obj =  {
add() {}
}
</code></pre>

<ul>
<li>使用Promise，async-await解决回调函数多层嵌套问题。</li>
</ul></li>
</ul>

<h2>注释与文档规范</h2>

<ul>
<li>单行注释（必须）

<ul>
<li>注释单独一行的情况下，注释的//后面要跟一个空格</li>
<li>注释如果和代码同一行，代码分号结束后，要跟一个空格，注释的//后也要跟一个空格
> 理由：写起来简单，看上去直观。</li>
</ul></li>
</ul>

<pre><code class="js">// 调用函数
foo();

var maxCount = 10; // 这是一个变量
</code></pre>

<ul>
<li>多行注释（必须）</li>
</ul>

<p>多行注释使用下面这种形式

<blockquote>
  理由：js统一的规范，官方也是这么写的。
</blockquote>

<pre><code class="js">/**
 * 代码注释1
 * 代码注释2
 */
 ```

  多行注释建议在以下几种情况使用：
  - 难于理解的代码段
  - 可能存在错误的代码段
  - 浏览器特殊的 HACK 代码
  - 业务逻辑强相关的代码

- 函数注释（必须）

复杂的函数，所有类，都必须进行标准函数注释，示例如下。
&gt; 理由：函数注释使用业界统一的规范，方便后续使用 jsdoc 生成文档。
```js
/**
 * 获取任务的名称
 * @param id {Number} 传入需要获取名称的人物id
 * @return {String} 返回的姓名
 * @author shi 2015/07/21 可以不写
 * @version 1.1.0 可以不写
 * @example 示例代码，可以不写
 */
function getTaskName(id) {
  let name = "test";
  return name;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>317</wp:post_id>
		<wp:post_date><![CDATA[2018-11-20 20:17:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-20 12:17:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%89%8d%e7%ab%af%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97-javascript%e7%af%87]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96"><![CDATA[前端优化]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96"><![CDATA[前端工程化]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>egg.js原理剖析：egg-cluster</title>
		<link>http://bugzhang.com/?p=331</link>
		<pubDate>Sat, 19 Oct 2019 08:51:01 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=331</guid>
		<description></description>
		<content:encoded><![CDATA[本文主要是egg-cluster的原理理解，包括了一些前置知识：操作系统进程同学、node创建进程、node进程通信。我对这些前置知识只会略讲，如果看到后没有任何印象或者之前不掌握，请阅读本文最后参考文档中的文章来熟悉这些前置知识再阅读本文。

<h1>node-cluster 简介</h1>

「cluster」意为“集群”，顾名思义，就是增加node.js这种单进程单线程的有效利用多核系统的能力。
「cluster」 模块可以创建共享服务器端口的子进程。

<h1>node.js 进程创建方式</h1>

通信方式与进程产生方式有关，而Node有4种创建进程的方式： spawn() ， exec() ， execFile() 和 fork()。

<ul>
<li>spawn：spawn() 方法默认不会创建shell去执行传入的命令，性能相对较好</li>
<li>exec：exec() 方法会创建一个shell，完全支持shell语法 ，可以直接传入任意shell脚本，故可以调用shell脚本</li>
<li>execFile：execFile() 相比 exec() 是不会通过shell，而是接受一个可执行文件</li>
<li>fork：fork() 是 spawn() 的变体，用来创建Node进程，最大的特点是父子进程自带通信机制——管道</li>
</ul>

<h1>操作系统 进程通信</h1>

<ul>
<li>共享内存：不同进程共享同一段内存空间。通常还需要引入信号量机制，来实现同步与互斥。这种方式性能极高，但实现困难。</li>
<li>消息传递：这种模式下，进程间通过发送、接收消息来实现信息的同步。</li>
<li>信号量：信号量简单说就是系统赋予进程的一个状态值，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量只有 0 或者 1 两个值的话，又被称作“互斥锁”。这个机制也被广泛用于各种编程模式中。</li>
<li>管道：管道本身也是一个进程，它用于连接两个进程，将一个进程的输出作为另一个进程的输入。可以用 pipe 系统调用来创建管道。我们经常用的“ | ”命令行就是利用了管道机制。</li>
<li>socket：网络通信，不仅能跨进程（端口与端口），还能跨机器（IP与IP）</li>
</ul>

<h1>node.js 进程通信</h1>

<ul>
<li>通过stdin/stdout传递消息：属于操作系统进程通信方式的消息传递法。拿到子进程的handle后，可以访问其 stdio 流，然后约定一种 message 格式通信。</li>
<li>IPC管道：默认通信方式，父进程与process.on('message') 收 | child.send() 发，子进程process.on('message') 收 | process.send() 发，和</li>
<li>socket：借助socket网络通信，不仅能跨进程（端口与端口），还能跨机器（IP与IP）。</li>
</ul>

<h1>node-cluster 工作原理</h1>

通常，一个集群由主从架构组成，就是一个「master」主进程和多个「worker」子进程来组成一个集群。
工作进程由「child_process.fork」方法创建，这些「worker」可以用IPC管道和父进程通信。子进程和父进程具有相同的代码段、数据段、堆栈，但是它们的内存空间不共享。父进程「master」负责监听端口，接收到新的请求派发给下面的「worker」进程。

<h1>egg-cluster 架构模型</h1>

egg-cluster把进程分为三类：
master：主进程，负责 agent 的启动、退出、重启；各个 worker 进程调度；负责 agent 和各个 worker 之间的通信；负责各个 worker 之间的通信
agent：「master」 的子进程，可以理解为「master」的“助理”，帮「master」打杂做一些派发之类的工作：处理公共资源的访问，如文件监听，或者帮 「worker」 处理一些公共事务，如一些事情是不需要每个 「worker」 都做一次的，「agent」 帮忙做完之后通知它们执行之后的操作
worker：「master」 的子进程，一般是根据服务器有多少个 CPU 启动多少个这样的 「worker」 进程，主要用于对外服务，处理各种业务层面的事情

<h1>进程顺序</h1>

<ul>
<li>master 启动后先启动 agent 进程</li>
<li>agent 初始化成功后，通过 IPC 通道通知 master</li>
<li>master 根据 CPU 的个数启动相同数目的 worker 进程</li>
<li>worker 进程初始化成功后，通过 IPC 通道通知 master</li>
<li>所有的进程初始化成功后，master 通知 agent 和各个 worker 进程应用启动成功</li>
</ul>

<h1>进程通信</h1>

master 和 agent/worker 是 直接通信的，因为 master 是 agent/worker fork()后的父进程，拥有IPC管道进行通信
agent 和 worker 之间以及各个 worker 之间是 间接通信的，依靠master做中转

https://github.com/eggjs/egg-cluster#readme

参考：

《现代操作系统》
进程间的五种通信方式介绍： https://blog.csdn.net/wh_sjc/article/details/70283843
node.js的cluster文档：http://nodejs.cn/api/cluster.html
Nodejs进程间通信： https://www.cnblogs.com/rubyxie/articles/8949417.html
egg-cluster：https://github.com/eggjs/egg-cluster#readme
Egg 源码解析之 egg-cluster：https://zhuanlan.zhihu.com/p/29374045#]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>331</wp:post_id>
		<wp:post_date><![CDATA[2019-10-19 16:51:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-19 08:51:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[egg-js%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90%ef%bc%9aegg-cluster]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="egg-js"><![CDATA[egg.js]]></category>
		<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="post_tag" nicename="node-js"><![CDATA[node.js]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_b00cb1827c86bf87ac310b3910448bab]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[125]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_76ef763d783029998dcb4ab0cda12865]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>基于前端微服务的对一款监控平台的技术方案改进</title>
		<link>http://bugzhang.com/?p=347</link>
		<pubDate>Fri, 01 Nov 2019 04:04:53 +0000</pubDate>
		<dc:creator><![CDATA[bugzhang]]></dc:creator>
		<guid isPermaLink="false">http://bugzhang.com/?p=347</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading -->

<h2>原始方案</h2>

<!-- /wp:heading -->

<!-- wp:image {"id":348} -->
<figure class="wp-block-image"><img src="http://bugzhang.com/wp-content/uploads/2019/11/image.png" alt="" class="wp-image-348"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
后端：Java框架Spring Boot整合数据库数据，推送给Grafana。
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
前端：完全依靠Grafana做前端，定制化很弱，无法完成大屏看板等刚需。
<!-- /wp:paragraph -->

<!-- wp:heading -->

<h2>改进方案1：完全定制化的前端</h2>

<!-- /wp:heading -->

<!-- wp:image {"id":349} -->
<figure class="wp-block-image"><img src="http://bugzhang.com/wp-content/uploads/2019/11/image-1.png" alt="" class="wp-image-349"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">干掉Grafana，完全定制化开发前端，采用Vue框架，以及数据可视化组件库Echarts和大屏组件库iDataV完成业务开发。</p>

<!-- /wp:paragraph -->

<!-- wp:heading -->

<h2>改进方案2：完全配置化的前端</h2>

<!-- /wp:heading -->

<!-- wp:image {"id":350} -->
<figure class="wp-block-image"><img src="http://bugzhang.com/wp-content/uploads/2019/11/image-2.png" alt="" class="wp-image-350"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
方案1有个明显确定是复用性非常差，以后类似项目又要重头再来，不如Grafana方便。
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
方案2用Node.js，替代Grafana的后端功能。引入MongoDB存储业务后端推送的数据。
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">每个页面可配置组件及其组件形式和样式，在运行时依靠配置编译出主题文件并且采用。可推送数据到不同组件实现监控。</p>

<!-- /wp:paragraph -->

<!-- wp:heading -->

<h2>改进方案3：基于微服务的对当前方案的改进</h2>

<!-- /wp:heading -->

<!-- wp:image {"id":351} -->
<figure class="wp-block-image"><img src="http://bugzhang.com/wp-content/uploads/2019/11/image-3.png" alt="" class="wp-image-351"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">方案2相比之前，功能非常齐全，可维护性很佳。难度在于实施工期非常长，并且目前业务Grafana基本能支持绝大多数场景，除了大屏展示效果不佳外是勉强可用的。</p>

<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">如果把大屏功能和Grafana数据可视化分离成两个微服务，然后用一个基座整合在一起，大屏功能和方案2一致，而Grafana完整保留，好处在于开发时间大大降低。得到方案3。</p>

<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->

<h3>前端微服务技术可选方案</h3>

<!-- /wp:heading -->

<!-- wp:table -->

<table class="wp-block-table"><tbody><tr><td>
<strong>方式</strong>
</td><td>
<strong>开发成本</strong>
</td><td>
<strong>维护成本</strong>
</td><td>
<strong>可行性</strong>
</td><td>
<strong>同一框架要求</strong>
</td><td>
<strong>实现难度</strong>
</td><td>
<strong>潜在风险</strong>
</td></tr><tr><td>
路由分发
</td><td>
低
</td><td>
低
</td><td>
高
</td><td>
否
</td><td>
★
</td><td>
不支持多种框架
</td></tr><tr><td>
iFrame
</td><td>
低
</td><td>
低
</td><td>
高
</td><td>
否
</td><td>
★
</td><td>
XSS风险，性能差
</td></tr><tr><td>
应用微服务化
</td><td>
高
</td><td>
低
</td><td>
中
</td><td>
否
</td><td>
★★★★
</td><td>
针对每个框架做定制及 Hook
</td></tr><tr><td>
微件化
</td><td>
高
</td><td>
中
</td><td>
低
</td><td>
是
</td><td>
★★★★★
</td><td>
针对构建系统，如 webpack 进行 hack
</td></tr><tr><td>
微应用化
</td><td>
中
</td><td>
中
</td><td>
高
</td><td>
是
</td><td>
★★★
</td><td>
统一不同应用的构建规范
</td></tr><tr><td>
纯 Web Components
</td><td>
高
</td><td>
低
</td><td>
高
</td><td>
否
</td><td>
★★
</td><td>
新技术，浏览器的兼容问题
</td></tr><tr><td>
结合 Web Components
</td><td>
高
</td><td>
低
</td><td>
高
</td><td>
否
</td><td>
★★
</td><td>
新技术，浏览器的兼容问题
</td></tr></tbody></table>

<!-- /wp:table -->

<!-- wp:image {"id":352} -->
<figure class="wp-block-image"><img src="http://bugzhang.com/wp-content/uploads/2019/11/image-4.png" alt="" class="wp-image-352"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">我们的业务：Y（不限框架） -&gt; N（不需要支持IE） -&gt; N （不是新项目因为有Grafana了）</p>

<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">得到选型：<strong>WebComponent 集成应用的方式</strong></p>

<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->

<p class="has-medium-font-size">其他关于web component是什么，怎么用，微服务是什么怎么用的。可以靠看参考文章来了解。</p>

<!-- /wp:paragraph -->

<!-- wp:separator -->

<hr class="wp-block-separator"/>

<!-- /wp:separator -->

<!-- wp:paragraph -->
参考文章：
<!-- /wp:paragraph -->

<!-- wp:list -->

<ul><li>前端微服务：<a href="https://github.com/phodal/microfrontends">https://github.com/phodal/microfrontends</a></li><li>WebComponent入门：<a href="http://www.ruanyifeng.com/blog/2019/08/web_components.html">http://www.ruanyifeng.com/blog/2019/08/web_components.html</a></li><li>vue-cli3中使用<strong>WebComponent</strong>：<a href="https://www.cnblogs.com/Adiodanza/p/9641708.html">https://www.cnblogs.com/Adiodanza/p/9641708.html</a></li></ul>

<!-- /wp:list -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>347</wp:post_id>
		<wp:post_date><![CDATA[2019-11-01 12:04:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-01 04:04:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9f%ba%e4%ba%8e%e5%be%ae%e6%9c%8d%e5%8a%a1%e7%9a%84%e4%b8%80%e6%ac%be%e5%af%b9%e7%9b%91%e6%8e%a7%e5%b9%b3%e5%8f%b0%e7%9a%84%e6%bc%94%e8%bf%9b__trashed]]></wp:post_name>
		<wp:status><![CDATA[trash]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="post_tag" nicename="node-js"><![CDATA[node.js]]></category>
		<category domain="category" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e6%9e%b6%e6%9e%84"><![CDATA[架构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
		<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
		<wp:meta_value><![CDATA[1574237682]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e5%9f%ba%e4%ba%8e%e5%be%ae%e6%9c%8d%e5%8a%a1%e7%9a%84%e4%b8%80%e6%ac%be%e5%af%b9%e7%9b%91%e6%8e%a7%e5%b9%b3%e5%8f%b0%e7%9a%84%e6%bc%94%e8%bf%9b]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	